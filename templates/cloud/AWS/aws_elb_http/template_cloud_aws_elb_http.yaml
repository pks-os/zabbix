zabbix_export:
  version: '7.2'
  template_groups:
    - uuid: c2c162144c2d4c5491c8801193af4945
      name: Templates/Cloud
  templates:
    - uuid: f59c8b4156ec4386a7c724534ddd384d
      template: 'AWS ELB Application Load Balancer by HTTP'
      name: 'AWS ELB Application Load Balancer by HTTP'
      description: |
        The template is designed to monitor AWS ELB Application Load Balancer by HTTP via Zabbix, and it works without any external scripts.
        Don't forget to read the README.md for the correct setup of the template.
        
        You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback
        
        Generated by official Zabbix template tool "Templator"
      vendor:
        name: Zabbix
        version: 7.2-0
      groups:
        - name: Templates/Cloud
      items:
        - uuid: cf1a45ea7ad74602b675d1fbe137c53d
          name: 'Active Connection Count'
          type: DEPENDENT
          key: aws.elb.alb.active_connection_count
          delay: '0'
          history: 7d
          description: 'The total number of active concurrent TCP connections from clients to the load balancer and from the load balancer to targets.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ActiveConnectionCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: connections
        - uuid: 4bd5c4e139374a60a42eb86a343f315e
          name: 'Get alarms check'
          type: DEPENDENT
          key: aws.elb.alb.alarms.check
          delay: '0'
          history: 7d
          trends: '0'
          value_type: CHAR
          description: 'Check that the alarm data has been received correctly.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
              error_handler: CUSTOM_VALUE
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          master_item:
            key: aws.elb.alb.get_alarms
          tags:
            - tag: component
              value: status
          triggers:
            - uuid: 3fd832d1a2cc4cff955554cbd8c4b3c7
              expression: 'length(last(/AWS ELB Application Load Balancer by HTTP/aws.elb.alb.alarms.check))>0'
              name: 'Failed to get alarms data'
              event_name: 'Failed to get CloudWatch alarms for Application Load Balancer'
              opdata: 'Current value: {ITEM.LASTVALUE1}'
              priority: WARNING
              description: 'Failed to get CloudWatch alarms for Application Load Balancer.'
              tags:
                - tag: scope
                  value: availability
        - uuid: 0f966c0ff2f344f58a5c049ea2bc503a
          name: 'ELB Auth Error'
          type: DEPENDENT
          key: aws.elb.alb.auth_error
          delay: '0'
          history: 7d
          description: 'The number of user authentications that could not be completed because an authenticate action was misconfigured, the load balancer could not establish a connection with the IdP, or the load balancer could not complete the authentication flow due to an internal error.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ELBAuthError")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: authorization
            - tag: component
              value: errors
        - uuid: 5f516687f9364f2f87b7fd1d2cbc8054
          name: 'ELB Auth Failure'
          type: DEPENDENT
          key: aws.elb.alb.auth_failure
          delay: '0'
          history: 7d
          description: 'The number of user authentications that could not be completed because the IdP denied access to the user or an authorization code was used more than once.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ELBAuthFailure")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: authorization
            - tag: component
              value: errors
        - uuid: bfae078db4a14fd6a31b94e87552e430
          name: 'ELB Auth Latency'
          type: DEPENDENT
          key: aws.elb.alb.auth_latency
          delay: '0'
          history: 7d
          value_type: FLOAT
          units: ms
          description: |
            The time elapsed, in milliseconds, to query the IdP for the ID token and user info.
            If one or more of these operations fail, this is the time to failure.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ELBAuthLatency")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: authorization
        - uuid: 3eed720ae5f948b287cf6ee0bdda41f1
          name: 'ELB Auth Success'
          type: DEPENDENT
          key: aws.elb.alb.auth_success
          delay: '0'
          history: 7d
          description: |
            The number of authenticate actions that were successful.
            This metric is incremented at the end of the authentication workflow, after the load balancer has retrieved the user claims from the IdP.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ELBAuthSuccess")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: authorization
        - uuid: 8562bd314951443faed4039c2c36b127
          name: 'ELB Auth User Claims Size Exceeded'
          type: DEPENDENT
          key: aws.elb.alb.auth_user_claims_size_exceeded
          delay: '0'
          history: 7d
          description: 'The number of times that a configured IdP returned user claims that exceeded 11K bytes in size.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ELBAuthUserClaimsSizeExceeded")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: authorization
            - tag: component
              value: errors
        - uuid: 4f06db3a2da446c28228a20ed04847e1
          name: 'Consumed LCUs'
          type: DEPENDENT
          key: aws.elb.alb.capacity_units
          delay: '0'
          history: 7d
          value_type: FLOAT
          description: |
            The number of load balancer capacity units (LCU) used by your load balancer.
            You pay for the number of LCUs that you use per hour.
            More information on Elastic Load Balancing pricing here: https://aws.amazon.com/elasticloadbalancing/pricing/
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ConsumedLCUs")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: capacity
        - uuid: c7e81227b5a648de9413ffcb6b9746ee
          name: 'Client TLS Negotiation Error Count'
          type: DEPENDENT
          key: aws.elb.alb.client_tls_negotiation_error_count
          delay: '0'
          history: 7d
          description: |
            The number of TLS connections initiated by the client that did not establish a session with the load balancer due to a TLS error.
            Possible causes include a mismatch of ciphers or protocols or the client failing to verify the server certificate and closing the connection.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ClientTLSNegotiationErrorCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: errors
        - uuid: 059b7697baba46b2a7f138a1011a0e0c
          name: 'Get ELB ALB alarms data'
          type: SCRIPT
          key: aws.elb.alb.get_alarms
          delay: 0s;m/1
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
            	params: {},
            	metadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	setParams: function (params) {
            		AWS.params['proxy'] = params.proxy;
            		switch (AWS.getField(params, 'auth_type')) {
            			case 'role_base':
            				AWS.params['auth_type'] = 'role_base';
            				var request = new HttpRequest();
            				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            					request.setProxy(AWS.params.proxy);
            				}
            				var IamRoleName = request.get(AWS.metadata);
            
            				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
            					throw 'Error getting security credentials from instance metadata. Role not found.';
            				}
            
            				credentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));
            
            				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
            					throw 'Error getting security credentials from instance metadata.';
            				}
            
            				try {
            					credentials = JSON.parse(credentials);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
            				}
            
            				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
            					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
            						throw 'Required credentials is not set: "' + field + '".';
            					};
            					AWS.params[field] = credentials[field];
            				});
            				break;
            			case 'access_key':
            			default:
            				AWS.params['auth_type'] = 'access_key';
            				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
            					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            						throw 'Required param is not set: "' + field + '".';
            					}
            					AWS.params[field] = params[field];
            				});
            		}
            		['region', 'arn'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            			AWS.params[field] = params[field];
            		});
            	},
            
            	sign: function (key, message) {
            		var hex = hmac('sha256', key, message);
            
            		if ((hex.length % 2) === 1) {
            			throw 'Invalid length of a hex string!';
            		}
            
            		var result = new Int8Array(hex.length / 2);
            		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
            			result[b] = parseInt(hex.substring(i, i + 2), 16);
            		}
            
            		return result;
            	},
            
            	prepareParams: function (params) {
            		var result = [];
            
            		Object.keys(params).sort().forEach(function (key) {
            			if (typeof params[key] !== 'object') {
            				result.push(key + '=' + encodeURIComponent(params[key]));
            			}
            			else {
            				result.push(prepareObject(key, params[key]));
            			}
            		});
            
            		return result.join('&');
            	},
            
            	request: function (method, region, service, params, data) {
            		if (typeof data === 'undefined' || data === null) {
            			data = '';
            		}
            
            		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            			date = amzdate.replace(/T\d+Z/, ''),
            			host = service + '.' + region + '.amazonaws.com',
            			canonical_uri = '/',
            			canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            			signed_headers = 'content-encoding;host;x-amz-date',
            			canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
            			credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
            		key = AWS.sign(key, region);
            		key = AWS.sign(key, service);
            		key = AWS.sign(key, 'aws4_request');
            
            		var request = new HttpRequest(),
            			url = 'https://' + host + canonical_uri + '?' + params;
            
            		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            			request.setProxy(AWS.params.proxy);
            		}
            		request.addHeader('x-amz-date: ' + amzdate);
            		request.addHeader('Accept: application/json');
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Content-Encoding: amz-1.0');
            		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
            		if (AWS.params.auth_type === 'role_base')
            			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
            		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
            
            		response = request.get(url);
            
            		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
            
            		if (request.getStatus() !== 200) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            
            		if (response[0] === '<') {
            			try {
            				response = XML.toJson(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
            			}
            		}
            
            		if (response !== null) {
            			try {
            				response = JSON.parse(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
            			}
            		}
            
            		return response;
            	},
            
            	getAlarms: function () {
            		var payload = {
            			'Action': 'DescribeAlarms',
            			'Version': '2010-08-01',
            			'MaxRecords': 100
            		},
            			result = [];
            
            		while (payload.NextToken !== '') {
            			var alarms = AWS.getField(AWS.request('GET', AWS.params.region, 'monitoring', AWS.prepareParams(payload)), 'DescribeAlarmsResponse.DescribeAlarmsResult');
            			payload.NextToken = alarms.NextToken || '';
            			alarms_list = AWS.getField(alarms, 'MetricAlarms');
            			regex = /loadbalancer\/(.+)$/;
            
            			if (!Array.isArray(alarms_list))
            				alarms_list = [alarms_list]
            			alarms_list.forEach(function (alarm) {
            				var dimensions = alarm.Dimensions;
            
            				Zabbix.log(4, '[ AWS ELB ] dimensions: ' + JSON.stringify(dimensions));
            				if (Array.isArray(alarm.Metrics)) {
            					alarm.Metrics.forEach(function (metric) {
            						if (typeof metric.MetricStat === 'object' && metric.MetricStat !== null
            							&& typeof metric.MetricStat.Metric === 'object' && metric.MetricStat.Metric !== null
            							&& Array.isArray(metric.MetricStat.Metric.Dimensions)) {
            							dimensions = dimensions.concat(metric.MetricStat.Metric.Dimensions);
            						}
            					});
            				}
            				for (var i in dimensions) {
            					if (dimensions[i].Name === 'LoadBalancer' && dimensions[i].Value === AWS.params.arn.match(regex)[1]) {
            						result.push(alarm);
            						break;
            					}
            				}
            			});
            		}
            
            		return result;
            	}
            };
            
            try {
            	AWS.setParams(JSON.parse(value));
            
            	return JSON.stringify(AWS.getAlarms());
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ AWS ELB Alarms ] ERROR: ' + error);
            
            	return JSON.stringify({ 'error': error });
            }
          description: '`DescribeAlarms` API method: https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeAlarms.html'
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - '-1'
          timeout: '{$AWS.DATA.TIMEOUT}'
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: arn
              value: '{$AWS.ELB.ARN}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: c7b4e867ff8246058d931ca76d18d4e7
          name: 'Get metrics data'
          type: SCRIPT
          key: aws.elb.alb.get_metrics
          delay: 0s;m/1
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
            	params: {},
            	metadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',
            	request_period: 60,
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	setParams: function (params) {
            		AWS.params['proxy'] = params.proxy;
            		switch (AWS.getField(params, 'auth_type')) {
            			case 'role_base':
            				AWS.params['auth_type'] = 'role_base';
            				var request = new HttpRequest();
            				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            					request.setProxy(AWS.params.proxy);
            				}
            				var IamRoleName = request.get(AWS.metadata);
            
            				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
            					throw 'Error getting security credentials from instance metadata. Role not found.';
            				}
            
            				credentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));
            
            				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
            					throw 'Error getting security credentials from instance metadata.';
            				}
            
            				try {
            					credentials = JSON.parse(credentials);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
            				}
            
            				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
            					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
            						throw 'Required credentials are not set: "' + field + '".';
            					};
            					AWS.params[field] = credentials[field];
            				});
            				break;
            			case 'access_key':
            			default:
            				AWS.params['auth_type'] = 'access_key';
            				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
            					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            						throw 'Required param is not set: "' + field + '".';
            					}
            					AWS.params[field] = params[field];
            				});
            		}
            		['region', 'arn'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            			AWS.params[field] = params[field];
            		});
            	},
            
            	sign: function (key, message) {
            		var hex = hmac('sha256', key, message);
            
            		if ((hex.length % 2) === 1) {
            			throw 'Invalid length of a hex string!';
            		}
            
            		var result = new Int8Array(hex.length / 2);
            		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
            			result[b] = parseInt(hex.substring(i, i + 2), 16);
            		}
            
            		return result;
            	},
            
            	renderMetricQuery: function (period, arn) {
            		var metrics_list = [
            			'ActiveConnectionCount:Sum',
            			'ClientTLSNegotiationErrorCount:Sum',
            			'ConsumedLCUs:Sum',
            			'DesyncMitigationMode_NonCompliant_Request_Count:Sum',
            			'HTTP_Fixed_Response_Count:Sum',
            			'HTTP_Redirect_Count:Sum',
            			'HTTP_Redirect_Url_Limit_Exceeded_Count:Sum',
            			'HTTPCode_ELB_3XX_Count:Sum',
            			'HTTPCode_ELB_4XX_Count:Sum',
            			'HTTPCode_ELB_5XX_Count:Sum',
            			'HTTPCode_ELB_500_Count:Sum',
            			'HTTPCode_ELB_502_Count:Sum',
            			'HTTPCode_ELB_503_Count:Sum',
            			'HTTPCode_ELB_504_Count:Sum',
            			'NewConnectionCount:Sum',
            			'ProcessedBytes:Sum',
            			'RejectedConnectionCount:Sum',
            			'RequestCount:Sum',
            			'RuleEvaluations:Sum',
            			'TargetResponseTime:Average',
            			'TargetTLSNegotiationErrorCount:Sum',
            			'TargetConnectionErrorCount:Sum',
            			'ELBAuthError:Sum',
            			'ELBAuthFailure:Sum',
            			'ELBAuthLatency:Sum',
            			'ELBAuthSuccess:Sum',
            			'ELBAuthUserClaimsSizeExceeded:Sum',
            		],
            			regex = /loadbalancer\/(.+)$/;
            
            		var metric_payload = [];
            		metrics_list.forEach(function (metric, index) {
            			var parts = metric.split(':', 2);
            			metric_payload.push({
            				'Id': 'm' + index,
            				'MetricStat': {
            					'Metric': {
            						'MetricName': parts[0],
            						'Namespace': 'AWS/ApplicationELB',
            						'Dimensions': [
            							{
            								'Name': 'LoadBalancer',
            								'Value': arn.match(regex)[1],
            							}
            						]
            					},
            					'Period': period,
            					'Stat': parts[1],
            				}
            			});
            		});
            
            		return metric_payload;
            	},
            
            	request: function (method, region, service, data) {
            		if (typeof data === 'undefined' || data === null) {
            			data = JSON.stringify([]);
            		}
            		else {
            			data = JSON.stringify(data)
            		}
            		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            			date = amzdate.replace(/T\d+Z/, ''),
            			canonical_uri = '/',
            			host = service + '.' + region + '.amazonaws.com';
            
            		if (AWS.params.auth_type === 'role_base') {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n' + 'x-amz-security-token:' + AWS.params.Token + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';
            		} else {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date';
            		}
            
            		canonical_request = method + '\n' + canonical_uri + '\n' + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data);
            		url = 'https://' + host + canonical_uri;
            
            		var credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
            		key = AWS.sign(key, region);
            		key = AWS.sign(key, service);
            		key = AWS.sign(key, 'aws4_request');
            
            		var request = new HttpRequest();
            
            		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            			request.setProxy(AWS.params.proxy);
            		}
            		request.addHeader('x-amz-date: ' + amzdate);
            		request.addHeader('x-amz-content-sha256:' + sha256(data));
            		request.addHeader('X-Amz-Target: GraniteServiceVersion20100801.GetMetricData')
            		request.addHeader('Accept: application/json');
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Content-Encoding: amz-1.0');
            		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
            		if (AWS.params.auth_type === 'role_base')
            			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
            		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
            		response = request.post(url, data);
            		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
            		if (request.getStatus() !== 200) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            
            		return JSON.parse(response);
            	},
            
            	getMetricsData: function () {
            		var end_time = Math.floor((new Date().getTime()) / 1000),
            			start_time = end_time - AWS.request_period * 60;
            		payload = {
            			'StartTime': start_time,
            			'EndTime': end_time,
            			'ScanBy': 'TimestampDescending',
            			'MetricDataQueries': AWS.renderMetricQuery(AWS.request_period, AWS.params.arn)
            		};
            
            		return AWS.getField(AWS.request('POST', AWS.params.region, 'monitoring', payload), 'MetricDataResults');
            	}
            };
            
            try {
            	AWS.setParams(JSON.parse(value));
            	return JSON.stringify(AWS.getMetricsData());
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ AWS ELB Get metrics] ERROR: ' + error);
            
            	return JSON.stringify({ 'error': error });
            }
          description: |
            Get ELB Application Load Balancer metrics.
            Full metrics list related to Application Load Balancer: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-cloudwatch-metrics.html
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - '-1'
          timeout: '{$AWS.DATA.TIMEOUT}'
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: arn
              value: '{$AWS.ELB.ARN}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: 9b118d348b934146bab54e2df582e2b0
          name: 'Get target groups'
          type: SCRIPT
          key: aws.elb.alb.get_target_groups
          delay: 0s;m/30
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
            	params: {},
            	metadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	setParams: function (params) {
            		AWS.params['proxy'] = params.proxy;
            		switch (AWS.getField(params, 'auth_type')) {
            			case 'role_base':
            				AWS.params['auth_type'] = 'role_base';
            				var request = new HttpRequest();
            				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            					request.setProxy(AWS.params.proxy);
            				}
            				var IamRoleName = request.get(AWS.metadata);
            
            				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
            					throw 'Error getting security credentials from instance metadata. Role not found.';
            				}
            
            				credentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));
            
            				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
            					throw 'Error getting security credentials from instance metadata.';
            				}
            
            				try {
            					credentials = JSON.parse(credentials);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
            				}
            
            				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
            					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
            						throw 'Required credentials are not set: "' + field + '".';
            					};
            					AWS.params[field] = credentials[field];
            				});
            				break;
            			case 'access_key':
            			default:
            				AWS.params['auth_type'] = 'access_key';
            				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
            					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            						throw 'Required param is not set: "' + field + '".';
            					}
            					AWS.params[field] = params[field];
            				});
            		}
            		['region', 'arn'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            			AWS.params[field] = params[field];
            		});
            	},
            
            	sign: function (key, message) {
            		var hex = hmac('sha256', key, message);
            
            		if ((hex.length % 2) === 1) {
            			throw 'Invalid length of a hex string!';
            		}
            
            		var result = new Int8Array(hex.length / 2);
            		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
            			result[b] = parseInt(hex.substring(i, i + 2), 16);
            		}
            
            		return result;
            	},
            
            	prepareParams: function (params) {
            		var result = [];
            
            		Object.keys(params).sort().forEach(function (key) {
            			if (typeof params[key] !== 'object') {
            				result.push(key + '=' + encodeURIComponent(params[key]));
            			}
            			else {
            				result.push(prepareObject(key, params[key]));
            			}
            		});
            
            		return result.join('&');
            	},
            
            	request: function (method, region, service, params, data) {
            		if (typeof data === 'undefined' || data === null) {
            			data = JSON.stringify([]);
            		}
            		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            			date = amzdate.replace(/T\d+Z/, ''),
            			canonical_uri = '/',
            			host = service + '.' + region + '.amazonaws.com';
            
            		if (AWS.params.auth_type === 'role_base') {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n' + 'x-amz-security-token:' + AWS.params.Token + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';
            		} else {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date';
            		}
            		canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data);
            		url = 'https://' + host + canonical_uri + '?' + params;
            		var credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
            		key = AWS.sign(key, region);
            		key = AWS.sign(key, service);
            		key = AWS.sign(key, 'aws4_request');
            
            		var request = new HttpRequest();
            
            		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            			request.setProxy(AWS.params.proxy);
            		}
            		request.addHeader('x-amz-date: ' + amzdate);
            		request.addHeader('x-amz-content-sha256:' + sha256(data));
            		request.addHeader('Accept: application/json');
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Content-Encoding: amz-1.0');
            		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
            		if (AWS.params.auth_type === 'role_base')
            			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
            		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
            		response = request.get(url);
            		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
            		if (request.getStatus() !== 200) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            
            		return JSON.parse(response);
            	},
            
            	listTargetGroups: function () {
            		var lld_array = [],
            			regex = /targetgroup\/(.+)$/,
            			payload = {
            				'Action': 'DescribeTargetGroups',
            				'LoadBalancerArn': AWS.params.arn,
            				'Version': '2015-12-01'
            			};
            		targets = AWS.getField(AWS.request('GET', AWS.params.region, 'elasticloadbalancing', AWS.prepareParams(payload), ''), 'DescribeTargetGroupsResponse.DescribeTargetGroupsResult.TargetGroups');
            
            		if (!Array.isArray(targets))
            			targets = [targets]
            
            		targets.forEach(function (targets) {
            			lld_array.push(
            				{
            					target_name: AWS.getField(targets, 'TargetGroupName'),
            					target_arn: AWS.getField(targets, 'TargetGroupArn').match(regex)[0],
            					type: AWS.getField(targets, 'TargetType'),
            					protocol: AWS.getField(targets, 'Protocol')
            				}
            			)
            		});
            
            		return lld_array;
            	}
            };
            
            try {
            	AWS.setParams(JSON.parse(value));
            	return JSON.stringify(AWS.listTargetGroups());
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ AWS ELB Target groups ] ERROR: ' + error);
            
            	return JSON.stringify({ 'error': error });
            }
          description: |
            Get ELB target group.
            `DescribeTargetGroups` API method: https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - '-1'
          timeout: '{$AWS.DATA.TIMEOUT}'
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: arn
              value: '{$AWS.ELB.ARN}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: eabcf1ef1514451087d08d739cf55d94
          name: 'ELB HTTP 3XX Count'
          type: DEPENDENT
          key: aws.elb.alb.http_3xx_count
          delay: '0'
          history: 7d
          description: |
            The number of HTTP 3XX redirection codes that originate from the load balancer.
            This count does not include response codes generated by targets.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_3XX_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 3xx
        - uuid: c714c1f2185b4b0b8b86e3ad336d7888
          name: 'ELB HTTP 4XX Count'
          type: DEPENDENT
          key: aws.elb.alb.http_4xx_count
          delay: '0'
          history: 7d
          description: |
            The number of HTTP 4XX client error codes that originate from the load balancer.
            Client errors are generated when requests are malformed or incomplete. These requests were not received by the target, other than in the case where the load balancer returns an HTTP 460 error code.
            This count does not include any response codes generated by the targets.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_4XX_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 4xx
          triggers:
            - uuid: 922bd3ab505b420984c93dfdfc417a56
              expression: 'min(/AWS ELB Application Load Balancer by HTTP/aws.elb.alb.http_4xx_count,5m)>{$AWS.HTTP.4XX.FAIL.MAX.WARN}'
              name: 'Too many HTTP 4XX error codes'
              event_name: 'Too many HTTP 4XX error codes (over {$AWS.HTTP.4XX.FAIL.MAX.WARN} for 5m)'
              opdata: 'Current value: {ITEM.LASTVALUE1}'
              priority: WARNING
              description: 'Too many requests failed with HTTP 4XX code.'
              tags:
                - tag: scope
                  value: availability
        - uuid: 6395ef49a60546ec8d3ce117867cbb43
          name: 'ELB HTTP 5XX Count'
          type: DEPENDENT
          key: aws.elb.alb.http_5xx_count
          delay: '0'
          history: 7d
          description: |
            The number of HTTP 5XX server error codes that originate from the load balancer.
            This count does not include any response codes generated by the targets.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_5XX_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 5xx
          triggers:
            - uuid: 883fc396e7da4806943cd70688c057a3
              expression: 'min(/AWS ELB Application Load Balancer by HTTP/aws.elb.alb.http_5xx_count,5m)>{$AWS.HTTP.5XX.FAIL.MAX.WARN}'
              name: 'Too many HTTP 5XX error codes'
              event_name: 'Too many HTTP 5XX error codes (over {$AWS.HTTP.5XX.FAIL.MAX.WARN} for 5m)'
              opdata: 'Current value: {ITEM.LASTVALUE1}'
              priority: WARNING
              description: 'Too many requests failed with HTTP 5XX code.'
              tags:
                - tag: scope
                  value: availability
        - uuid: 7bf9230aa56b4196b386d23358da75ed
          name: 'ELB HTTP 500 Count'
          type: DEPENDENT
          key: aws.elb.alb.http_500_count
          delay: '0'
          history: 7d
          description: 'The number of HTTP 500 error codes that originate from the load balancer.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_500_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 5xx
            - tag: http-code
              value: '500'
        - uuid: f89bee8030774615a132d25a6d1b7a2a
          name: 'ELB HTTP 502 Count'
          type: DEPENDENT
          key: aws.elb.alb.http_502_count
          delay: '0'
          history: 7d
          description: 'The number of HTTP 502 error codes that originate from the load balancer.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_502_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 5xx
            - tag: http-code
              value: '502'
        - uuid: bca5eaf0b96c496395ed98e8d4705153
          name: 'ELB HTTP 503 Count'
          type: DEPENDENT
          key: aws.elb.alb.http_503_count
          delay: '0'
          history: 7d
          description: 'The number of HTTP 503 error codes that originate from the load balancer.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_503_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 5xx
            - tag: http-code
              value: '503'
        - uuid: 5d1c57a6483c4b84b992f9677f6216c1
          name: 'ELB HTTP 504 Count'
          type: DEPENDENT
          key: aws.elb.alb.http_504_count
          delay: '0'
          history: 7d
          description: 'The number of HTTP 504 error codes that originate from the load balancer.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_504_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 5xx
            - tag: http-code
              value: '504'
        - uuid: 115bdaf06c554f9a8b3a486c28d218cd
          name: 'HTTP Fixed Response Count'
          type: DEPENDENT
          key: aws.elb.alb.http_fixed_response_count
          delay: '0'
          history: 7d
          description: 'The number of fixed-response actions that were successful.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTP_Fixed_Response_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: responses
        - uuid: 4edc1d8d4eb84832996943ac571afb5f
          name: 'HTTP Redirect Count'
          type: DEPENDENT
          key: aws.elb.alb.http_redirect_count
          delay: '0'
          history: 7d
          description: 'The number of redirect actions that were successful.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTP_Redirect_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: http
        - uuid: fbf24a4f2110416d973a8f11c8770d98
          name: 'HTTP Redirect Url Limit Exceeded Count'
          type: DEPENDENT
          key: aws.elb.alb.http_redirect_url_limit_exceeded_count
          delay: '0'
          history: 7d
          description: 'The number of redirect actions that could not be completed because the URL in the response location header is larger than 8K bytes.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTP_Redirect_Url_Limit_Exceeded_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: http
        - uuid: 7fdd931458ba4fa5b3baff1d67e4a32f
          name: 'Get metrics check'
          type: DEPENDENT
          key: aws.elb.alb.metrics.check
          delay: '0'
          history: 7d
          trends: '0'
          value_type: CHAR
          description: 'Check that the Application Load Balancer metrics data has been received correctly.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
              error_handler: CUSTOM_VALUE
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: status
          triggers:
            - uuid: 70282eb6c0c442f9a4f4c49b10f54a4d
              expression: 'length(last(/AWS ELB Application Load Balancer by HTTP/aws.elb.alb.metrics.check))>0'
              name: 'Failed to get metrics data'
              event_name: 'Failed to get CloudWatch metrics for Application Load Balancer'
              opdata: 'Current value: {ITEM.LASTVALUE1}'
              priority: WARNING
              description: 'Failed to get CloudWatch metrics for Application Load Balancer.'
              tags:
                - tag: scope
                  value: availability
        - uuid: 740872a3328e4c12827d8fcd16eb43ea
          name: 'New Connection Count'
          type: DEPENDENT
          key: aws.elb.alb.new_connection_count
          delay: '0'
          history: 7d
          description: 'The total number of new TCP connections established from clients to the load balancer and from the load balancer to targets.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "NewConnectionCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: connections
        - uuid: 4e3cf684607741e39248929e6b917be7
          name: 'Desync Mitigation Mode Non Compliant Request Count'
          type: DEPENDENT
          key: aws.elb.alb.non_compliant_request_count
          delay: '0'
          history: 7d
          description: 'The number of requests that fail to comply with HTTP protocols.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "DesyncMitigationMode_NonCompliant_Request_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: errors
        - uuid: 32b5fbc67cec4d739bbd95ba1cd77ab9
          name: 'Processed Bytes'
          type: DEPENDENT
          key: aws.elb.alb.processed_bytes
          delay: '0'
          history: 7d
          value_type: FLOAT
          units: B
          description: |
            The total number of bytes processed by the load balancer over IPv4 and IPv6 (HTTP header and HTTP payload).
            This count includes traffic to and from clients and Lambda functions, and traffic from an Identity Provider (IdP) if user authentication is enabled.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ProcessedBytes")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: capacity
        - uuid: ed3c4ebc1faf43ff9be134ae98aac0e9
          name: 'Rejected Connection Count'
          type: DEPENDENT
          key: aws.elb.alb.rejected_connection_count
          delay: '0'
          history: 7d
          description: 'The number of connections that were rejected because the load balancer had reached its maximum number of connections.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "RejectedConnectionCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: connections
        - uuid: 4b5b059c30ef4f8bb4d11a273d071db1
          name: 'Requests Count'
          type: DEPENDENT
          key: aws.elb.alb.requests_count
          delay: '0'
          history: 7d
          description: |
            The number of requests processed over IPv4 and IPv6.
            This metric is only incremented for requests where the load balancer node was able to choose a target.
            Requests that are rejected before a target is chosen are not reflected in this metric.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "RequestCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: requests
        - uuid: b5105b9e48f4482db42ff948f906be6f
          name: 'Rule Evaluations'
          type: DEPENDENT
          key: aws.elb.alb.rule_evaluations
          delay: '0'
          history: 7d
          description: 'The number of rules processed by the load balancer given a request rate averaged over an hour.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "RuleEvaluations")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: requests
        - uuid: 09cd066b48544eb7ac818bc6171e3e87
          name: 'Target Connection Error Count'
          type: DEPENDENT
          key: aws.elb.alb.target_connection_error_count
          delay: '0'
          history: 7d
          description: |
            The number of connections that were not successfully established between the load balancer and target.
            This metric does not apply if the target is a Lambda function.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TargetConnectionErrorCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: errors
        - uuid: 560c74f7011b4b9c821dfdf7f8d8e93a
          name: 'Target Response Time'
          type: DEPENDENT
          key: aws.elb.alb.target_response_time
          delay: '0'
          history: 7d
          value_type: FLOAT
          units: s
          description: |
            The time elapsed, in seconds, after the request leaves the load balancer until a response from the target is received.
            This is equivalent to the `target_processing_time` field in the access logs.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TargetResponseTime")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: responses
        - uuid: 66d56d14553d4de69a63745ab02f2611
          name: 'Target TLS Negotiation Error Count'
          type: DEPENDENT
          key: aws.elb.alb.target_tls_negotiation_error_count
          delay: '0'
          history: 7d
          description: |
            The number of TLS connections initiated by the load balancer that did not establish a session with the target.
            Possible causes include a mismatch of ciphers or protocols. This metric does not apply if the target is a Lambda function.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TargetTLSNegotiationErrorCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.alb.get_metrics
          tags:
            - tag: component
              value: errors
      discovery_rules:
        - uuid: 065ef42ebea5448896db5fcc5baa2f81
          name: 'Load Balancer alarm discovery'
          type: DEPENDENT
          key: aws.elb.alb.alarms.discovery
          delay: '0'
          filter:
            evaltype: AND
            conditions:
              - macro: '{#ALARM_NAME}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.MATCHES}'
                formulaid: A
              - macro: '{#ALARM_NAME}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#ALARM_SERVICE_NAMESPACE}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.MATCHES}'
                formulaid: C
              - macro: '{#ALARM_SERVICE_NAMESPACE}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Used for the discovery of alarm balancers.'
          item_prototypes:
            - uuid: fca522690827426bb63f93e90d98aa54
              name: '[{#ALARM_NAME}]: Get metrics'
              type: DEPENDENT
              key: 'aws.elb.alb.alarm.get_metrics["{#ALARM_NAME}"]'
              delay: '0'
              history: '0'
              trends: '0'
              value_type: TEXT
              description: 'Get metrics about the alarm state and its reason.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.AlarmName == "{#ALARM_NAME}")].first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: aws.elb.alb.get_alarms
              tags:
                - tag: component
                  value: raw
            - uuid: 3ef62eb9b0824f8ea3c2c1e8e15ce1fd
              name: '[{#ALARM_NAME}]: State'
              type: DEPENDENT
              key: 'aws.elb.alb.alarm.state["{#ALARM_NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The value of the alarm state. Possible values:
                0 - OK;
                1 - INSUFFICIENT_DATA;
                2 - ALARM.
                Alarm description:
                `{#ALARM_DESCRIPTION}`
              valuemap:
                name: 'Alarm state'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.StateValue
                  error_handler: CUSTOM_VALUE
                  error_handler_params: '3'
                - type: JAVASCRIPT
                  parameters:
                    - |
                      var state = ['OK', 'INSUFFICIENT_DATA', 'ALARM'];
                      
                      return state.indexOf(value.trim()) === -1 ? 255 : state.indexOf(value.trim());
              master_item:
                key: 'aws.elb.alb.alarm.get_metrics["{#ALARM_NAME}"]'
              tags:
                - tag: component
                  value: alarms
              trigger_prototypes:
                - uuid: b8bbc96a20bc4ab393d1fa76a3cf5254
                  expression: 'last(/AWS ELB Application Load Balancer by HTTP/aws.elb.alb.alarm.state["{#ALARM_NAME}"])=1'
                  name: '[{#ALARM_NAME}] has ''Insufficient data'' state'
                  event_name: '[{#ALARM_NAME}] has ''Insufficient data'' state'
                  opdata: 'Current value: {ITEM.LASTVALUE1}'
                  priority: INFO
                  description: 'Either the alarm has just started, the metric is not available, or not enough data is available for the metric to determine the alarm state.'
                  tags:
                    - tag: scope
                      value: notice
            - uuid: 8839a61a10f7453ebfdcae0ef16eb37c
              name: '[{#ALARM_NAME}]: State reason'
              type: DEPENDENT
              key: 'aws.elb.alb.alarm.state_reason["{#ALARM_NAME}"]'
              delay: '0'
              history: 7d
              trends: '0'
              value_type: TEXT
              description: |
                An explanation for the alarm state reason in text format.
                Alarm description:
                `{#ALARM_DESCRIPTION}`
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.StateReason
                  error_handler: DISCARD_VALUE
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'aws.elb.alb.alarm.get_metrics["{#ALARM_NAME}"]'
              tags:
                - tag: component
                  value: alarms
          trigger_prototypes:
            - uuid: a1b8587c80dd41ef8b185cf62e563bcb
              expression: 'last(/AWS ELB Application Load Balancer by HTTP/aws.elb.alb.alarm.state["{#ALARM_NAME}"])=2 and length(last(/AWS ELB Application Load Balancer by HTTP/aws.elb.alb.alarm.state_reason["{#ALARM_NAME}"]))>0'
              name: '[{#ALARM_NAME}] has ''Alarm'' state'
              event_name: '[{#ALARM_NAME}] has ''Alarm'' state (reason: {ITEM.LASTVALUE2})'
              opdata: 'Reason: {ITEM.LASTVALUE2}'
              priority: AVERAGE
              description: |
                The alarm `{#ALARM_NAME}` is in the ALARM state.
                Reason: `{ITEM.LASTVALUE2}`
              tags:
                - tag: scope
                  value: availability
          master_item:
            key: aws.elb.alb.get_alarms
          preprocessing:
            - type: JAVASCRIPT
              parameters:
                - |
                  var result = [];
                  var alarms = JSON.parse(value);
                  
                  alarms.forEach(function(alarm) {
                  
                   result.push({
                  '{#ALARM_DESCRIPTION}': alarm.AlarmDescription !== null ? alarm.AlarmDescription : 'None' ,
                  '{#ALARM_NAME}': alarm.AlarmName,
                  '{#ALARM_PERIOD}': alarm.Period,
                  '{#METRIC_NAME}': alarm.MetricName,
                  '{#ALARM_SERVICE_NAMESPACE}': alarm.Namespace !== null ? alarm.Namespace : 'None'
                    });
                  });
                  
                  return JSON.stringify(result);
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: 1002081ffffd40828ff5419c50bc16d5
          name: 'Target groups discovery'
          type: DEPENDENT
          key: aws.elb.alb.target_groups.discovery
          delay: '0'
          filter:
            evaltype: AND
            conditions:
              - macro: '{#AWS.ELB.TARGET.GROUP.NAME}'
                value: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.MATCHES}'
                formulaid: A
              - macro: '{#AWS.ELB.TARGET.GROUP.NAME}'
                value: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
          description: 'Used for the discovery of `{$AWS.ELB.TARGET.GROUP.NAME}` target groups.'
          item_prototypes:
            - uuid: 21d1830526e14fb99b2288d79747d472
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Anomalous Host Count'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.anomalous_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of hosts detected with anomalies.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "AnomalousHostCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 306971d2e8fb441d8ae4a658b26304c3
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Get metrics'
              type: SCRIPT
              key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: 0s;m/5
              history: '0'
              trends: '0'
              value_type: TEXT
              params: |
                var AWS = {
                	params: {},
                	metadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',
                	request_period: 60,
                
                	getField: function (data, path) {
                		var steps = path.split('.');
                		for (var i = 0; i < steps.length; i++) {
                			var step = steps[i];
                			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
                				throw 'Required field was not found: ' + path;
                			}
                
                			data = data[step];
                		}
                
                		return data;
                	},
                
                	setParams: function (params) {
                		AWS.params['proxy'] = params.proxy;
                		switch (AWS.getField(params, 'auth_type')) {
                			case 'role_base':
                				AWS.params['auth_type'] = 'role_base';
                				var request = new HttpRequest();
                				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                					request.setProxy(AWS.params.proxy);
                				}
                				var IamRoleName = request.get(AWS.metadata);
                
                				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
                					throw 'Error getting security credentials from instance metadata. Role not found.';
                				}
                
                				credentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));
                
                				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
                					throw 'Error getting security credentials from instance metadata.';
                				}
                
                				try {
                					credentials = JSON.parse(credentials);
                				}
                				catch (error) {
                					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
                				}
                
                				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
                					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
                						throw 'Required credentials are not set: "' + field + '".';
                					};
                					AWS.params[field] = credentials[field];
                				});
                				break;
                			case 'access_key':
                			default:
                				AWS.params['auth_type'] = 'access_key';
                				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
                					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                						throw 'Required param is not set: "' + field + '".';
                					}
                					AWS.params[field] = params[field];
                				});
                		}
                		['region', 'arn', 'target_arn'].forEach(function (field) {
                			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                				throw 'Required param is not set: "' + field + '".';
                			}
                			AWS.params[field] = params[field];
                		});
                	},
                
                	sign: function (key, message) {
                		var hex = hmac('sha256', key, message);
                
                		if ((hex.length % 2) === 1) {
                			throw 'Invalid length of a hex string!';
                		}
                
                		var result = new Int8Array(hex.length / 2);
                		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
                			result[b] = parseInt(hex.substring(i, i + 2), 16);
                		}
                
                		return result;
                	},
                
                	renderMetricQuery: function (period, arn, target_arn) {
                		var metrics_list = [
                			'HTTPCode_Target_2XX_Count:Sum',
                			'HTTPCode_Target_3XX_Count:Sum',
                			'HTTPCode_Target_4XX_Count:Sum',
                			'HTTPCode_Target_5XX_Count:Sum',
                			'HealthyHostCount:Average',
                			'UnHealthyHostCount:Average',
                			'HealthyStateRouting:Sum',
                			'UnhealthyStateRouting:Sum',
                			'UnhealthyRoutingRequestCount:Sum',
                			'HealthyStateDNS:Sum',
                			'UnhealthyStateDNS:Sum',
                			'RequestCountPerTarget:Sum',
                			'MitigatedHostCount:Average',
                			'AnomalousHostCount:Average',
                		],
                			regex = /loadbalancer\/(.+)$/;
                
                		var metric_payload = [];
                		metrics_list.forEach(function (metric, index) {
                			var parts = metric.split(':', 2);
                			metric_payload.push({
                				'Id': 'm' + index,
                				'MetricStat': {
                					'Metric': {
                						'MetricName': parts[0],
                						'Namespace': 'AWS/ApplicationELB',
                						'Dimensions': [
                							{
                								'Name': 'LoadBalancer',
                								'Value': arn.match(regex)[1],
                							},
                							{
                								'Name': 'TargetGroup',
                								'Value': target_arn
                							}
                						]
                					},
                					'Period': period,
                					'Stat': parts[1],
                				}
                			});
                		});
                
                		return metric_payload;
                	},
                
                	request: function (method, region, service, data) {
                		if (typeof data === 'undefined' || data === null) {
                			data = JSON.stringify([]);
                		}
                		else {
                			data = JSON.stringify(data)
                		}
                		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
                			date = amzdate.replace(/T\d+Z/, ''),
                			canonical_uri = '/',
                			host = service + '.' + region + '.amazonaws.com';
                
                		if (AWS.params.auth_type === 'role_base') {
                			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n' + 'x-amz-security-token:' + AWS.params.Token + '\n',
                				signed_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';
                		} else {
                			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
                				signed_headers = 'content-encoding;host;x-amz-date';
                		}
                
                		canonical_request = method + '\n' + canonical_uri + '\n' + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data);
                		url = 'https://' + host + canonical_uri;
                
                		var credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
                			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
                			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
                
                		key = AWS.sign(key, region);
                		key = AWS.sign(key, service);
                		key = AWS.sign(key, 'aws4_request');
                
                		var request = new HttpRequest();
                
                		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                			request.setProxy(AWS.params.proxy);
                		}
                		request.addHeader('x-amz-date: ' + amzdate);
                		request.addHeader('x-amz-content-sha256:' + sha256(data));
                		request.addHeader('X-Amz-Target: GraniteServiceVersion20100801.GetMetricData')
                		request.addHeader('Accept: application/json');
                		request.addHeader('Content-Type: application/json');
                		request.addHeader('Content-Encoding: amz-1.0');
                		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
                		if (AWS.params.auth_type === 'role_base')
                			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
                
                		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
                		response = request.post(url, data);
                		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
                		if (request.getStatus() !== 200) {
                			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
                		}
                
                		return JSON.parse(response);
                	},
                
                	getMetricsData: function () {
                		var end_time = Math.floor((new Date().getTime()) / 1000),
                			start_time = end_time - AWS.request_period * 60;
                		payload = {
                			'StartTime': start_time,
                			'EndTime': end_time,
                			'ScanBy': 'TimestampDescending',
                			'MetricDataQueries': AWS.renderMetricQuery(AWS.request_period, AWS.params.arn, AWS.params.target_arn)
                		};
                
                		return AWS.getField(AWS.request('POST', AWS.params.region, 'monitoring', payload), 'MetricDataResults');
                	}
                };
                
                try {
                	AWS.setParams(JSON.parse(value));
                	return JSON.stringify(AWS.getMetricsData());
                }
                catch (error) {
                	error += (String(error).endsWith('.')) ? '' : '.';
                	Zabbix.log(3, '[ AWS ELB Get targets group metrics] ERROR: ' + error);
                
                	return JSON.stringify({ 'error': error });
                }
              description: |
                Get the metrics of the ELB target group `{#AWS.ELB.TARGET.GROUP.NAME}`.
                Full list of metrics related to AWS ELB here: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-cloudwatch-metrics.html#user-authentication-metric-table
              preprocessing:
                - type: CHECK_NOT_SUPPORTED
                  parameters:
                    - '-1'
              timeout: '{$AWS.DATA.TIMEOUT}'
              parameters:
                - name: AccessKeyId
                  value: '{$AWS.ACCESS.KEY.ID}'
                - name: arn
                  value: '{$AWS.ELB.ARN}'
                - name: auth_type
                  value: '{$AWS.AUTH_TYPE}'
                - name: proxy
                  value: '{$AWS.PROXY}'
                - name: region
                  value: '{$AWS.REGION}'
                - name: SecretAccessKey
                  value: '{$AWS.SECRET.ACCESS.KEY}'
                - name: target_arn
                  value: '{#AWS.ELB.TARGET.GROUP.ARN}'
              tags:
                - tag: component
                  value: raw
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: e4cd95136bb04981b15a508aa73f5723
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy Host Count'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.healthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of targets that are considered healthy.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HealthyHostCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: b96ad1d2f5064cc99c49eeec3801418e
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy State DNS'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.healthy_state_dns["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of zones that meet the DNS healthy state requirements.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HealthyStateDNS")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 030c4fe8b7f44bf3a290b1b5da9319d8
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy State Routing'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.healthy_state_routing["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of zones that meet the routing healthy state requirements.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HealthyStateRouting")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: fa9da54b4feb4fc79fbf74c491eb23ba
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: HTTP Code Target 2XX Count'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.http_2xx_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The number of HTTP response 2XX codes generated by the targets.
                This does not include any response codes generated by the load balancer.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HTTPCode_Target_2XX_Count")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: http
                - tag: component
                  value: target-groups
                - tag: http-code
                  value: 2xx
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 50e78304f9e74019b7e06310d6dd2e6f
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: HTTP Code Target 3XX Count'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.http_3xx_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The number of HTTP response 3XX codes generated by the targets.
                This does not include any response codes generated by the load balancer.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HTTPCode_Target_3XX_Count")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: http
                - tag: component
                  value: target-groups
                - tag: http-code
                  value: 3xx
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: ec7b92c79c6f441cadb8994b906753f4
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: HTTP Code Target 4XX Count'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.http_4xx_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The number of HTTP response 4XX codes generated by the targets.
                This does not include any response codes generated by the load balancer.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HTTPCode_Target_4XX_Count")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: http
                - tag: component
                  value: target-groups
                - tag: http-code
                  value: 4xx
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: c9e61f9d2f12496d90693a83cb829b66
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: HTTP Code Target 5XX Count'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.http_5xx_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The number of HTTP response 5XX codes generated by the targets.
                This does not include any response codes generated by the load balancer.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HTTPCode_Target_5XX_Count")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: http
                - tag: component
                  value: target-groups
                - tag: http-code
                  value: 5xx
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 0ad4d9a933944c7d979da411d24b165e
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Mitigated Host Count'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.mitigated_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of targets under mitigation.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "MitigatedHostCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 31a579ac8de9402bae3a3668779ec6c5
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Request Count Per Target'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.request["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The average request count per target, in a target group.
                You must specify the target group using the TargetGroup dimension.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "RequestCountPerTarget")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: requests
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: c158172738084d38aec424505a7a86a5
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy Host Count'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.unhealthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of targets that are considered unhealthy.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "UnHealthyHostCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 9fea4b63067445d98d29de566d50b0a4
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy Routing Request Count'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.unhealthy_routing_request_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The average request count per target, in a target group.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "UnhealthyRoutingRequestCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: requests
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: f050e9610eb64251b55e843fc5eb5876
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy State DNS'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.unhealthy_state_dns["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of zones that do not meet the DNS healthy state requirements and therefore were marked unhealthy in DNS.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "UnhealthyStateDNS")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 2a446451893e4f70a0d4ac4b1bb969fb
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy State Routing'
              type: DEPENDENT
              key: 'aws.elb.alb.target_groups.unhealthy_state_routing["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of zones that do not meet the routing healthy state requirements, and therefore the load balancer distributes traffic to all targets in the zone, including the unhealthy targets.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "UnhealthyStateRouting")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.alb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
          graph_prototypes:
            - uuid: f426eff334d449ff9ec0a2ff8f6ee103
              name: 'AWS ELB ALB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy Host'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: 199C0D
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.alb.target_groups.healthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: f6f8d317322a420ab4e0025b3b284a98
              name: 'AWS ELB ALB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy State DNS'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: 199C0D
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.alb.target_groups.healthy_state_dns["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: 40922ff1845141c7a2488fe24debeae0
              name: 'AWS ELB ALB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy State Routing'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: 199C0D
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.alb.target_groups.healthy_state_routing["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: a2668f5bf6a240a296b047c1b979f9dc
              name: 'AWS ELB ALB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy Host'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: FF0000
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.alb.target_groups.unhealthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: 54645b74585c4b45a971c13d1127698d
              name: 'AWS ELB ALB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy State DNS'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: FF0000
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.alb.target_groups.unhealthy_state_dns["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: 8da12e20218e4367968b8fcf0f56991a
              name: 'AWS ELB ALB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy State Routing'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: FF0000
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.alb.target_groups.unhealthy_state_routing["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: ec38c670cabf422ea79f41866c90ee66
              name: 'AWS ELB ALB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}] HTTP Code Target Group'
              graph_items:
                - drawtype: BOLD_LINE
                  color: 199C0D
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.alb.target_groups.http_2xx_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
                - sortorder: '1'
                  drawtype: BOLD_LINE
                  color: F63100
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.alb.target_groups.http_3xx_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
                - sortorder: '2'
                  drawtype: BOLD_LINE
                  color: 00611C
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.alb.target_groups.http_4xx_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
                - sortorder: '3'
                  drawtype: BOLD_LINE
                  color: F7941D
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.alb.target_groups.http_5xx_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
          master_item:
            key: aws.elb.alb.get_target_groups
          lld_macro_paths:
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.ARN}'
              path: $.target_arn
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.NAME}'
              path: $.target_name
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
              path: $.protocol
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.TYPE}'
              path: $.type
          preprocessing:
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
      tags:
        - tag: class
          value: software
        - tag: target
          value: alb
        - tag: target
          value: aws
        - tag: target
          value: elb
      macros:
        - macro: '{$AWS.ACCESS.KEY.ID}'
          description: 'Access key ID.'
        - macro: '{$AWS.AUTH_TYPE}'
          value: access_key
          description: 'Authorization method. Possible values: `role_base`, `access_key`.'
        - macro: '{$AWS.DATA.TIMEOUT}'
          value: 60s
          description: 'API response timeout.'
        - macro: '{$AWS.ELB.ARN}'
          description: 'Amazon Resource Names (ARN) of the load balancer.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable alarms by name.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered alarms by name.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable alarms by namespace.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered alarms by namespace.'
        - macro: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable target groups by name.'
        - macro: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered target groups by name.'
        - macro: '{$AWS.HTTP.4XX.FAIL.MAX.WARN}'
          value: '5'
          description: 'Maximum number of HTTP request failures for a trigger expression.'
        - macro: '{$AWS.HTTP.5XX.FAIL.MAX.WARN}'
          value: '5'
          description: 'Maximum number of HTTP request failures for a trigger expression.'
        - macro: '{$AWS.PROXY}'
          description: 'Sets the HTTP proxy value. If this macro is empty, no proxy is used.'
        - macro: '{$AWS.REGION}'
          value: us-west-1
          description: 'AWS Application Load Balancer region code.'
        - macro: '{$AWS.SECRET.ACCESS.KEY}'
          description: 'Secret access key.'
      dashboards:
        - uuid: 1020fa347dd24a2ba4091528e63639d4
          name: 'Overview AWS ELB Application Load Balancer'
          pages:
            - name: 'AWS ELB ALB: Metrics'
              widgets:
                - type: svggraph
                  name: 'AWS ELB ALB: HTTP Code'
                  width: '72'
                  height: '5'
                  fields:
                    - type: STRING
                      name: ds.0.color.0
                      value: FFA726
                    - type: STRING
                      name: ds.0.color.1
                      value: FF465C
                    - type: STRING
                      name: ds.0.color.2
                      value: FF5722
                    - type: INTEGER
                      name: ds.0.dataset_type
                      value: '0'
                    - type: ITEM
                      name: ds.0.itemids.0
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        key: aws.elb.alb.http_3xx_count
                    - type: ITEM
                      name: ds.0.itemids.1
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        key: aws.elb.alb.http_4xx_count
                    - type: ITEM
                      name: ds.0.itemids.2
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        key: aws.elb.alb.http_5xx_count
                    - type: STRING
                      name: reference
                      value: AAAAD
                    - type: INTEGER
                      name: simple_triggers
                      value: '1'
                    - type: INTEGER
                      name: working_time
                      value: '1'
                - type: svggraph
                  name: 'AWS ELB ALB: Connection Count'
                  'y': '5'
                  width: '72'
                  height: '5'
                  fields:
                    - type: STRING
                      name: ds.0.color.0
                      value: 4CAF50
                    - type: STRING
                      name: ds.0.color.1
                      value: 0080FF
                    - type: STRING
                      name: ds.0.color.2
                      value: CC6600
                    - type: STRING
                      name: ds.0.color.3
                      value: B71C1C
                    - type: INTEGER
                      name: ds.0.dataset_type
                      value: '0'
                    - type: ITEM
                      name: ds.0.itemids.0
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        key: aws.elb.alb.active_connection_count
                    - type: ITEM
                      name: ds.0.itemids.1
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        key: aws.elb.alb.new_connection_count
                    - type: ITEM
                      name: ds.0.itemids.2
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        key: aws.elb.alb.rejected_connection_count
                    - type: ITEM
                      name: ds.0.itemids.3
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        key: aws.elb.alb.target_connection_error_count
                    - type: STRING
                      name: reference
                      value: AAAAC
                    - type: INTEGER
                      name: simple_triggers
                      value: '1'
                    - type: INTEGER
                      name: working_time
                      value: '1'
                - type: svggraph
                  name: 'AWS ELB ALB: Requests Count and Response Time'
                  'y': '10'
                  width: '72'
                  height: '5'
                  fields:
                    - type: STRING
                      name: ds.0.color.0
                      value: 0080FF
                    - type: INTEGER
                      name: ds.0.dataset_type
                      value: '0'
                    - type: ITEM
                      name: ds.0.itemids.0
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        key: aws.elb.alb.requests_count
                    - type: INTEGER
                      name: ds.1.axisy
                      value: '1'
                    - type: STRING
                      name: ds.1.color.0
                      value: B0AF07
                    - type: INTEGER
                      name: ds.1.dataset_type
                      value: '0'
                    - type: ITEM
                      name: ds.1.itemids.0
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        key: aws.elb.alb.target_response_time
                    - type: STRING
                      name: reference
                      value: AAAAB
                    - type: INTEGER
                      name: working_time
                      value: '1'
                - type: svggraph
                  name: 'AWS ELB ALB: Consumed LCUs and Processed Bytes'
                  'y': '15'
                  width: '72'
                  height: '5'
                  fields:
                    - type: STRING
                      name: ds.0.color.0
                      value: 78909C
                    - type: INTEGER
                      name: ds.0.dataset_type
                      value: '0'
                    - type: ITEM
                      name: ds.0.itemids.0
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        key: aws.elb.alb.capacity_units
                    - type: INTEGER
                      name: ds.1.axisy
                      value: '1'
                    - type: STRING
                      name: ds.1.color.0
                      value: AB47BC
                    - type: INTEGER
                      name: ds.1.dataset_type
                      value: '0'
                    - type: ITEM
                      name: ds.1.itemids.0
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        key: aws.elb.alb.processed_bytes
                    - type: STRING
                      name: reference
                      value: AAAAA
                    - type: INTEGER
                      name: working_time
                      value: '1'
            - name: 'AWS ELB ALB Target Groups: Metrics'
              widgets:
                - type: piechart
                  name: 'Healthy Host Count'
                  width: '12'
                  height: '4'
                  fields:
                    - type: INTEGER
                      name: draw_type
                      value: '1'
                    - type: STRING
                      name: ds.0.color
                      value: 00FF00
                    - type: STRING
                      name: ds.0.data_set_label
                      value: 'Healthy Host Count'
                    - type: STRING
                      name: ds.0.items.0
                      value: 'AWS ELB ALB Target Groups: *: Healthy Host Count'
                    - type: INTEGER
                      name: legend_aggregation
                      value: '1'
                    - type: INTEGER
                      name: total_show
                      value: '1'
                - type: svggraph
                  name: 'HTTP Code Target Group'
                  'y': '4'
                  width: '72'
                  height: '5'
                  fields:
                    - type: STRING
                      name: ds.0.data_set_label
                      value: 'HTTP Code Target Group'
                    - type: STRING
                      name: ds.0.items.0
                      value: 'AWS ELB ALB Target Groups: *: HTTP Code Target*'
                    - type: INTEGER
                      name: ds.0.transparency
                      value: '6'
                    - type: INTEGER
                      name: ds.0.type
                      value: '3'
                    - type: STRING
                      name: reference
                      value: QZUQY
                - type: svggraph
                  name: 'Request Count Per Target'
                  'y': '9'
                  width: '72'
                  height: '5'
                  fields:
                    - type: STRING
                      name: ds.0.color
                      value: 388E3C
                    - type: STRING
                      name: ds.0.data_set_label
                      value: 'Request Count Per Target'
                    - type: INTEGER
                      name: ds.0.fill
                      value: '5'
                    - type: STRING
                      name: ds.0.items.0
                      value: 'AWS ELB ALB Target Groups: *: Request Count Per Target'
                    - type: INTEGER
                      name: ds.0.missingdatafunc
                      value: '2'
                    - type: INTEGER
                      name: ds.0.transparency
                      value: '7'
                    - type: INTEGER
                      name: ds.0.width
                      value: '6'
                    - type: STRING
                      name: reference
                      value: COJBR
                - type: piechart
                  name: 'Unhealthy Host Count'
                  x: '12'
                  width: '12'
                  height: '4'
                  fields:
                    - type: INTEGER
                      name: draw_type
                      value: '1'
                    - type: STRING
                      name: ds.0.data_set_label
                      value: 'Unhealthy Host Count'
                    - type: STRING
                      name: ds.0.items.0
                      value: 'AWS ELB ALB Target Groups: *: Unhealthy Host Count'
                    - type: INTEGER
                      name: legend_aggregation
                      value: '1'
                    - type: INTEGER
                      name: total_show
                      value: '1'
                - type: piechart
                  name: 'Healthy State Routing'
                  x: '24'
                  width: '12'
                  height: '4'
                  fields:
                    - type: INTEGER
                      name: draw_type
                      value: '1'
                    - type: STRING
                      name: ds.0.color
                      value: 00897B
                    - type: STRING
                      name: ds.0.data_set_label
                      value: 'Healthy State Routing'
                    - type: STRING
                      name: ds.0.items.0
                      value: 'AWS ELB ALB Target Groups: *: Healthy State Routing'
                    - type: INTEGER
                      name: legend_aggregation
                      value: '1'
                    - type: INTEGER
                      name: total_show
                      value: '1'
                - type: piechart
                  name: 'Unhealthy State Routing'
                  x: '36'
                  width: '12'
                  height: '4'
                  fields:
                    - type: INTEGER
                      name: draw_type
                      value: '1'
                    - type: STRING
                      name: ds.0.data_set_label
                      value: 'Unhealthy State Routing'
                    - type: STRING
                      name: ds.0.items.0
                      value: 'AWS ELB ALB Target Groups: *: Unhealthy State Routing'
                    - type: INTEGER
                      name: legend_aggregation
                      value: '1'
                    - type: INTEGER
                      name: total_show
                      value: '1'
                - type: piechart
                  name: 'Healthy State DNS'
                  x: '48'
                  width: '12'
                  height: '4'
                  fields:
                    - type: INTEGER
                      name: draw_type
                      value: '1'
                    - type: STRING
                      name: ds.0.color
                      value: '283593'
                    - type: STRING
                      name: ds.0.data_set_label
                      value: 'Healthy State DNS'
                    - type: STRING
                      name: ds.0.items.0
                      value: 'AWS ELB ALB Target Groups: *: Healthy State DNS'
                    - type: INTEGER
                      name: legend_aggregation
                      value: '1'
                    - type: INTEGER
                      name: total_show
                      value: '1'
                - type: piechart
                  name: 'Unhealthy State DNS'
                  x: '60'
                  width: '12'
                  height: '4'
                  fields:
                    - type: INTEGER
                      name: draw_type
                      value: '1'
                    - type: STRING
                      name: ds.0.data_set_label
                      value: 'Unhealthy State DNS'
                    - type: STRING
                      name: ds.0.items.0
                      value: 'AWS ELB ALB Target Groups: *: Unhealthy State DNS'
                    - type: INTEGER
                      name: legend_aggregation
                      value: '1'
                    - type: INTEGER
                      name: total_show
                      value: '1'
      valuemaps:
        - uuid: 4bb749152d5d452ead36c5a98c3cac16
          name: 'Alarm state'
          mappings:
            - value: '0'
              newvalue: OK
            - value: '1'
              newvalue: 'Insufficient data'
            - value: '2'
              newvalue: Alarm
            - value: '255'
              newvalue: Unknown
    - uuid: 4c7d0c6e342b40458611bdb6e9dd958f
      template: 'AWS ELB Network Load Balancer by HTTP'
      name: 'AWS ELB Network Load Balancer by HTTP'
      description: |
        The template is designed to monitor AWS ELB Network Load Balancer by HTTP via Zabbix, and it works without any external scripts.
        Don't forget to read the README.md for the correct setup of the template.
        
        You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback
        
        Generated by official Zabbix template tool "Templator"
      vendor:
        name: Zabbix
        version: 7.2-0
      groups:
        - name: Templates/Cloud
      items:
        - uuid: 170a4e084c3748dfa1cfcbb1b168ff4c
          name: 'Active Flow Count'
          type: DEPENDENT
          key: aws.elb.nlb.active_flow_count
          delay: '0'
          history: 7d
          description: |
            The total number of concurrent flows (or connections) from clients to targets.
            This metric includes connections in the `SYN_SENT` and `ESTABLISHED` states.
            TCP connections are not terminated at the load balancer, so a client opening a TCP connection to a target counts as a single flow.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ActiveFlowCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
        - uuid: fd00c2998ae145ab821acde0a1515fbb
          name: 'Active Flow Count TCP'
          type: DEPENDENT
          key: aws.elb.nlb.active_flow_count_tcp
          delay: '0'
          history: 7d
          description: |
            The total number of concurrent TCP flows (or connections) from clients to targets.
            This metric includes connections in the `SYN_SENT` and `ESTABLISHED` states.
            TCP connections are not terminated at the load balancer, so a client opening a TCP connection to a target counts as a single flow.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ActiveFlowCount_TCP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: tcp
        - uuid: 31ae92c16e5643d3a67f392661518723
          name: 'Active Flow Count TLS'
          type: DEPENDENT
          key: aws.elb.nlb.active_flow_count_tls
          delay: '0'
          history: 7d
          description: |
            The total number of concurrent TLS flows (or connections) from clients to targets.
            This metric includes connections in the `SYN_SENT` and `ESTABLISHED` states.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ActiveFlowCount_TLS")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: tls
        - uuid: 7ba1f232eacc41cfa6e38939128b9ee1
          name: 'Active Flow Count UDP'
          type: DEPENDENT
          key: aws.elb.nlb.active_flow_count_udp
          delay: '0'
          history: 7d
          description: 'The total number of concurrent UDP flows (or connections) from clients to targets.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ActiveFlowCount_UDP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: udp
        - uuid: 397ce9711a404da48ebdfde65c24ff3b
          name: 'Get alarms check'
          type: DEPENDENT
          key: aws.elb.nlb.alarms.check
          delay: '0'
          history: 7d
          trends: '0'
          value_type: CHAR
          description: 'Check that the alarm data has been received correctly.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
              error_handler: CUSTOM_VALUE
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          master_item:
            key: aws.elb.nlb.get_alarms
          tags:
            - tag: component
              value: status
          triggers:
            - uuid: 4319dc0d484b456a9343535db3c079f4
              expression: 'length(last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.alarms.check))>0'
              name: 'Failed to get alarms data'
              event_name: 'Failed to get CloudWatch alarms for Network Load Balancer'
              opdata: 'Current value: {ITEM.LASTVALUE1}'
              priority: WARNING
              description: 'Failed to get CloudWatch alarms for Network Load Balancer.'
              tags:
                - tag: scope
                  value: availability
        - uuid: b2ef5e512e674a969853b389f308664e
          name: 'Consumed LCUs'
          type: DEPENDENT
          key: aws.elb.nlb.capacity_units
          delay: '0'
          history: 7d
          description: |
            The number of load balancer capacity units (LCU) used by your load balancer.
            You pay for the number of LCUs that you use per hour.
            More information on Elastic Load Balancing pricing here: https://aws.amazon.com/elasticloadbalancing/pricing/
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ConsumedLCUs")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: capacity
        - uuid: 33c9d9d275c04811b7dcb6806e8a9d9a
          name: 'Consumed LCUs TCP'
          type: DEPENDENT
          key: aws.elb.nlb.capacity_units_tcp
          delay: '0'
          history: 7d
          description: |
            The number of load balancer capacity units (LCU) used by your load balancer for TCP.
            You pay for the number of LCUs that you use per hour.
            More information on Elastic Load Balancing pricing here: https://aws.amazon.com/elasticloadbalancing/pricing/
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ConsumedLCUs_TCP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: capacity
            - tag: component
              value: tcp
        - uuid: bbcd303cbf654dc68fb40216994eef84
          name: 'Consumed LCUs TLS'
          type: DEPENDENT
          key: aws.elb.nlb.capacity_units_tls
          delay: '0'
          history: 7d
          description: |
            The number of load balancer capacity units (LCU) used by your load balancer for TLS.
            You pay for the number of LCUs that you use per hour.
            More information on Elastic Load Balancing pricing here: https://aws.amazon.com/elasticloadbalancing/pricing/
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ConsumedLCUs_TLS")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: capacity
            - tag: component
              value: tls
        - uuid: 90742c0ffb4844668f59a75f26132b18
          name: 'Consumed LCUs UDP'
          type: DEPENDENT
          key: aws.elb.nlb.capacity_units_udp
          delay: '0'
          history: 7d
          description: |
            The number of load balancer capacity units (LCU) used by your load balancer for UDP.
            You pay for the number of LCUs that you use per hour.
            More information on Elastic Load Balancing pricing here: https://aws.amazon.com/elasticloadbalancing/pricing/
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ConsumedLCUs_UDP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: capacity
            - tag: component
              value: udp
        - uuid: 6bbe06db758f40da9c2e0cb825b2aac3
          name: 'Client TLS Negotiation Error Count'
          type: DEPENDENT
          key: aws.elb.nlb.client_tls_negotiation_error_count
          delay: '0'
          history: 7d
          description: 'The total number of TLS handshakes that failed during negotiation between a client and a TLS listener.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ClientTLSNegotiationErrorCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
            - tag: component
              value: tls
        - uuid: 6d74c1a68ea9476dadc39b785f333d5d
          name: 'Get ELB NLB alarms data'
          type: SCRIPT
          key: aws.elb.nlb.get_alarms
          delay: 0s;m/1
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
            	params: {},
            	metadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	setParams: function (params) {
            		AWS.params['proxy'] = params.proxy;
            		switch (AWS.getField(params, 'auth_type')) {
            			case 'role_base':
            				AWS.params['auth_type'] = 'role_base';
            				var request = new HttpRequest();
            				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            					request.setProxy(AWS.params.proxy);
            				}
            				var IamRoleName = request.get(AWS.metadata);
            
            				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
            					throw 'Error getting security credentials from instance metadata. Role not found.';
            				}
            
            				credentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));
            
            				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
            					throw 'Error getting security credentials from instance metadata.';
            				}
            
            				try {
            					credentials = JSON.parse(credentials);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
            				}
            
            				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
            					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
            						throw 'Required credentials is not set: "' + field + '".';
            					};
            					AWS.params[field] = credentials[field];
            				});
            				break;
            			case 'access_key':
            			default:
            				AWS.params['auth_type'] = 'access_key';
            				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
            					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            						throw 'Required param is not set: "' + field + '".';
            					}
            					AWS.params[field] = params[field];
            				});
            		}
            		['region', 'arn'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            			AWS.params[field] = params[field];
            		});
            	},
            
            	sign: function (key, message) {
            		var hex = hmac('sha256', key, message);
            
            		if ((hex.length % 2) === 1) {
            			throw 'Invalid length of a hex string!';
            		}
            
            		var result = new Int8Array(hex.length / 2);
            		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
            			result[b] = parseInt(hex.substring(i, i + 2), 16);
            		}
            
            		return result;
            	},
            
            	prepareParams: function (params) {
            		var result = [];
            
            		Object.keys(params).sort().forEach(function (key) {
            			if (typeof params[key] !== 'object') {
            				result.push(key + '=' + encodeURIComponent(params[key]));
            			}
            			else {
            				result.push(prepareObject(key, params[key]));
            			}
            		});
            
            		return result.join('&');
            	},
            
            	request: function (method, region, service, params, data) {
            		if (typeof data === 'undefined' || data === null) {
            			data = '';
            		}
            
            		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            			date = amzdate.replace(/T\d+Z/, ''),
            			host = service + '.' + region + '.amazonaws.com',
            			canonical_uri = '/',
            			canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            			signed_headers = 'content-encoding;host;x-amz-date',
            			canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
            			credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
            		key = AWS.sign(key, region);
            		key = AWS.sign(key, service);
            		key = AWS.sign(key, 'aws4_request');
            
            		var request = new HttpRequest(),
            			url = 'https://' + host + canonical_uri + '?' + params;
            
            		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            			request.setProxy(AWS.params.proxy);
            		}
            		request.addHeader('x-amz-date: ' + amzdate);
            		request.addHeader('Accept: application/json');
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Content-Encoding: amz-1.0');
            		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
            		if (AWS.params.auth_type === 'role_base')
            			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
            		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
            
            		response = request.get(url);
            
            		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
            
            		if (request.getStatus() !== 200) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            
            		if (response[0] === '<') {
            			try {
            				response = XML.toJson(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
            			}
            		}
            
            		if (response !== null) {
            			try {
            				response = JSON.parse(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
            			}
            		}
            
            		return response;
            	},
            
            	getAlarms: function () {
            		var payload = {
            			'Action': 'DescribeAlarms',
            			'Version': '2010-08-01',
            			'MaxRecords': 100
            		},
            			result = [];
            
            		while (payload.NextToken !== '') {
            			var alarms = AWS.getField(AWS.request('GET', AWS.params.region, 'monitoring', AWS.prepareParams(payload)), 'DescribeAlarmsResponse.DescribeAlarmsResult');
            			payload.NextToken = alarms.NextToken || '';
            			alarms_list = AWS.getField(alarms, 'MetricAlarms');
            			regex = /loadbalancer\/(.+)$/;
            
            			if (!Array.isArray(alarms_list))
            				alarms_list = [alarms_list]
            			alarms_list.forEach(function (alarm) {
            				var dimensions = alarm.Dimensions;
            
            				Zabbix.log(4, '[ AWS ELB ] dimensions: ' + JSON.stringify(dimensions));
            				if (Array.isArray(alarm.Metrics)) {
            					alarm.Metrics.forEach(function (metric) {
            						if (typeof metric.MetricStat === 'object' && metric.MetricStat !== null
            							&& typeof metric.MetricStat.Metric === 'object' && metric.MetricStat.Metric !== null
            							&& Array.isArray(metric.MetricStat.Metric.Dimensions)) {
            							dimensions = dimensions.concat(metric.MetricStat.Metric.Dimensions);
            						}
            					});
            				}
            				for (var i in dimensions) {
            					if (dimensions[i].Name === 'LoadBalancer' && dimensions[i].Value === AWS.params.arn.match(regex)[1]) {
            						result.push(alarm);
            						break;
            					}
            				}
            			});
            		}
            
            		return result;
            	}
            };
            
            try {
            	AWS.setParams(JSON.parse(value));
            
            	return JSON.stringify(AWS.getAlarms());
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ AWS ELB Alarms ] ERROR: ' + error);
            
            	return JSON.stringify({ 'error': error });
            }
          description: '`DescribeAlarms` API method: https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeAlarms.html'
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - '-1'
          timeout: '{$AWS.DATA.TIMEOUT}'
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: arn
              value: '{$AWS.ELB.ARN}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: 76d374302b29430c8fe5813656ffd928
          name: 'Get metrics data'
          type: SCRIPT
          key: aws.elb.nlb.get_metrics
          delay: 0s;m/1
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
            	params: {},
            	metadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',
            	request_period: 60,
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	setParams: function (params) {
            		AWS.params['proxy'] = params.proxy;
            		switch (AWS.getField(params, 'auth_type')) {
            			case 'role_base':
            				AWS.params['auth_type'] = 'role_base';
            				var request = new HttpRequest();
            				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            					request.setProxy(AWS.params.proxy);
            				}
            				var IamRoleName = request.get(AWS.metadata);
            
            				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
            					throw 'Error getting security credentials from instance metadata. Role not found.';
            				}
            
            				credentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));
            
            				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
            					throw 'Error getting security credentials from instance metadata.';
            				}
            
            				try {
            					credentials = JSON.parse(credentials);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
            				}
            
            				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
            					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
            						throw 'Required credentials are not set: "' + field + '".';
            					};
            					AWS.params[field] = credentials[field];
            				});
            				break;
            			case 'access_key':
            			default:
            				AWS.params['auth_type'] = 'access_key';
            				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
            					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            						throw 'Required param is not set: "' + field + '".';
            					}
            					AWS.params[field] = params[field];
            				});
            		}
            		['region', 'arn'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            			AWS.params[field] = params[field];
            		});
            	},
            
            	sign: function (key, message) {
            		var hex = hmac('sha256', key, message);
            
            		if ((hex.length % 2) === 1) {
            			throw 'Invalid length of a hex string!';
            		}
            
            		var result = new Int8Array(hex.length / 2);
            		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
            			result[b] = parseInt(hex.substring(i, i + 2), 16);
            		}
            
            		return result;
            	},
            
            	renderMetricQuery: function (period, arn) {
            		var metrics_list = [
            			'ActiveFlowCount:Average',
            			'ActiveFlowCount_TCP:Average',
            			'ActiveFlowCount_TLS:Average',
            			'ActiveFlowCount_UDP:Average',
            			'ClientTLSNegotiationErrorCount:Sum',
            			'ConsumedLCUs:Sum',
            			'ConsumedLCUs_TCP:Sum',
            			'ConsumedLCUs_TLS:Sum',
            			'ConsumedLCUs_UDP:Sum',
            			'NewFlowCount:Sum',
            			'NewFlowCount_TCP:Sum',
            			'NewFlowCount_TLS:Sum',
            			'NewFlowCount_UDP:Sum',
            			'PeakPacketsPerSecond:Maximum',
            			'PortAllocationErrorCount:Sum',
            			'SecurityGroupBlockedFlowCount_Inbound_ICMP:Sum',
            			'SecurityGroupBlockedFlowCount_Inbound_TCP:Sum',
            			'SecurityGroupBlockedFlowCount_Inbound_UDP:Sum',
            			'SecurityGroupBlockedFlowCount_Outbound_ICMP:Sum',
            			'SecurityGroupBlockedFlowCount_Outbound_TCP:Sum',
            			'SecurityGroupBlockedFlowCount_Outbound_UDP:Sum',
            			'ProcessedBytes:Sum',
            			'ProcessedBytes_TCP:Sum',
            			'ProcessedBytes_TLS:Sum',
            			'ProcessedBytes_UDP:Sum',
            			'ProcessedPackets:Sum',
            			'TargetTLSNegotiationErrorCount:Sum',
            			'TCP_Client_Reset_Count:Sum',
            			'TCP_ELB_Reset_Count:Sum',
            			'TCP_Target_Reset_Count:Sum',
            			'UnhealthyRoutingFlowCount:Sum'
            		],
            			regex = /loadbalancer\/(.+)$/;
            
            		var metric_payload = [];
            		metrics_list.forEach(function (metric, index) {
            			var parts = metric.split(':', 2);
            			metric_payload.push({
            				'Id': 'm' + index,
            				'MetricStat': {
            					'Metric': {
            						'MetricName': parts[0],
            						'Namespace': 'AWS/NetworkELB',
            						'Dimensions': [
            							{
            								'Name': 'LoadBalancer',
            								'Value': arn.match(regex)[1],
            							}
            						]
            					},
            					'Period': period,
            					'Stat': parts[1],
            				}
            			});
            		});
            
            		return metric_payload;
            	},
            
            	request: function (method, region, service, data) {
            		if (typeof data === 'undefined' || data === null) {
            			data = JSON.stringify([]);
            		}
            		else {
            			data = JSON.stringify(data)
            		}
            		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            			date = amzdate.replace(/T\d+Z/, ''),
            			canonical_uri = '/',
            			host = service + '.' + region + '.amazonaws.com';
            
            		if (AWS.params.auth_type === 'role_base') {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n' + 'x-amz-security-token:' + AWS.params.Token + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';
            		} else {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date';
            		}
            
            		canonical_request = method + '\n' + canonical_uri + '\n' + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data);
            		url = 'https://' + host + canonical_uri;
            
            		var credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
            		key = AWS.sign(key, region);
            		key = AWS.sign(key, service);
            		key = AWS.sign(key, 'aws4_request');
            
            		var request = new HttpRequest();
            
            		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            			request.setProxy(AWS.params.proxy);
            		}
            		request.addHeader('x-amz-date: ' + amzdate);
            		request.addHeader('x-amz-content-sha256:' + sha256(data));
            		request.addHeader('X-Amz-Target: GraniteServiceVersion20100801.GetMetricData')
            		request.addHeader('Accept: application/json');
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Content-Encoding: amz-1.0');
            		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
            		if (AWS.params.auth_type === 'role_base')
            			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
            		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
            		response = request.post(url, data);
            		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
            		if (request.getStatus() !== 200) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            
            		return JSON.parse(response);
            	},
            
            	getMetricsData: function () {
            		var end_time = Math.floor((new Date().getTime()) / 1000),
            			start_time = end_time - AWS.request_period * 60;
            		payload = {
            			'StartTime': start_time,
            			'EndTime': end_time,
            			'ScanBy': 'TimestampDescending',
            			'MetricDataQueries': AWS.renderMetricQuery(AWS.request_period, AWS.params.arn)
            		};
            
            		return AWS.getField(AWS.request('POST', AWS.params.region, 'monitoring', payload), 'MetricDataResults');
            	}
            };
            
            try {
            	AWS.setParams(JSON.parse(value));
            	return JSON.stringify(AWS.getMetricsData());
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ AWS ELB Get metrics] ERROR: ' + error);
            
            	return JSON.stringify({ 'error': error });
            }
          description: |
            Get ELB Network Load Balancer metrics.
            Full metrics list related to Network Load Balancer: https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-cloudwatch-metrics.html
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - '-1'
          timeout: '{$AWS.DATA.TIMEOUT}'
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: arn
              value: '{$AWS.ELB.ARN}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: d80c238267744bc9b46de217acd93842
          name: 'Get target groups'
          type: SCRIPT
          key: aws.elb.nlb.get_target_groups
          delay: 0s;m/30
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
            	params: {},
            	metadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	setParams: function (params) {
            		AWS.params['proxy'] = params.proxy;
            		switch (AWS.getField(params, 'auth_type')) {
            			case 'role_base':
            				AWS.params['auth_type'] = 'role_base';
            				var request = new HttpRequest();
            				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            					request.setProxy(AWS.params.proxy);
            				}
            				var IamRoleName = request.get(AWS.metadata);
            
            				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
            					throw 'Error getting security credentials from instance metadata. Role not found.';
            				}
            
            				credentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));
            
            				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
            					throw 'Error getting security credentials from instance metadata.';
            				}
            
            				try {
            					credentials = JSON.parse(credentials);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
            				}
            
            				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
            					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
            						throw 'Required credentials are not set: "' + field + '".';
            					};
            					AWS.params[field] = credentials[field];
            				});
            				break;
            			case 'access_key':
            			default:
            				AWS.params['auth_type'] = 'access_key';
            				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
            					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            						throw 'Required param is not set: "' + field + '".';
            					}
            					AWS.params[field] = params[field];
            				});
            		}
            		['region', 'arn'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            			AWS.params[field] = params[field];
            		});
            	},
            
            	sign: function (key, message) {
            		var hex = hmac('sha256', key, message);
            
            		if ((hex.length % 2) === 1) {
            			throw 'Invalid length of a hex string!';
            		}
            
            		var result = new Int8Array(hex.length / 2);
            		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
            			result[b] = parseInt(hex.substring(i, i + 2), 16);
            		}
            
            		return result;
            	},
            
            	prepareParams: function (params) {
            		var result = [];
            
            		Object.keys(params).sort().forEach(function (key) {
            			if (typeof params[key] !== 'object') {
            				result.push(key + '=' + encodeURIComponent(params[key]));
            			}
            			else {
            				result.push(prepareObject(key, params[key]));
            			}
            		});
            
            		return result.join('&');
            	},
            
            	request: function (method, region, service, params, data) {
            		if (typeof data === 'undefined' || data === null) {
            			data = JSON.stringify([]);
            		}
            		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            			date = amzdate.replace(/T\d+Z/, ''),
            			canonical_uri = '/',
            			host = service + '.' + region + '.amazonaws.com';
            
            		if (AWS.params.auth_type === 'role_base') {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n' + 'x-amz-security-token:' + AWS.params.Token + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';
            		} else {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date';
            		}
            		canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data);
            		url = 'https://' + host + canonical_uri + '?' + params;
            		var credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
            		key = AWS.sign(key, region);
            		key = AWS.sign(key, service);
            		key = AWS.sign(key, 'aws4_request');
            
            		var request = new HttpRequest();
            
            		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            			request.setProxy(AWS.params.proxy);
            		}
            		request.addHeader('x-amz-date: ' + amzdate);
            		request.addHeader('x-amz-content-sha256:' + sha256(data));
            		request.addHeader('Accept: application/json');
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Content-Encoding: amz-1.0');
            		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
            		if (AWS.params.auth_type === 'role_base')
            			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
            		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
            		response = request.get(url);
            		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
            		if (request.getStatus() !== 200) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            
            		return JSON.parse(response);
            	},
            
            	listTargetGroups: function () {
            		var lld_array = [],
            			regex = /targetgroup\/(.+)$/,
            			payload = {
            				'Action': 'DescribeTargetGroups',
            				'LoadBalancerArn': AWS.params.arn,
            				'Version': '2015-12-01'
            			};
            		targets = AWS.getField(AWS.request('GET', AWS.params.region, 'elasticloadbalancing', AWS.prepareParams(payload), ''), 'DescribeTargetGroupsResponse.DescribeTargetGroupsResult.TargetGroups');
            
            		if (!Array.isArray(targets))
            			targets = [targets]
            
            		targets.forEach(function (targets) {
            			lld_array.push(
            				{
            					target_name: AWS.getField(targets, 'TargetGroupName'),
            					target_arn: AWS.getField(targets, 'TargetGroupArn').match(regex)[0],
            					type: AWS.getField(targets, 'TargetType'),
            					protocol: AWS.getField(targets, 'Protocol')
            				}
            			)
            		});
            
            		return lld_array;
            	}
            };
            
            try {
            	AWS.setParams(JSON.parse(value));
            	return JSON.stringify(AWS.listTargetGroups());
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ AWS ELB Target groups ] ERROR: ' + error);
            
            	return JSON.stringify({ 'error': error });
            }
          description: |
            Get ELB target group.
            `DescribeTargetGroups` API method: https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - '-1'
          timeout: '{$AWS.DATA.TIMEOUT}'
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: arn
              value: '{$AWS.ELB.ARN}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: 13516270f6124bf09a308bc20565528c
          name: 'Get metrics check'
          type: DEPENDENT
          key: aws.elb.nlb.metrics.check
          delay: '0'
          history: 7d
          trends: '0'
          value_type: CHAR
          description: 'Check that the Network Load Balancer metrics data has been received correctly.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
              error_handler: CUSTOM_VALUE
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: status
          triggers:
            - uuid: c2ba26fed3324a2bb9b90493a99db088
              expression: 'length(last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.metrics.check))>0'
              name: 'Failed to get metrics data'
              event_name: 'Failed to get CloudWatch metrics for Network Load Balancer'
              opdata: 'Current value: {ITEM.LASTVALUE1}'
              priority: WARNING
              description: 'Failed to get CloudWatch metrics for Network Load Balancer.'
              tags:
                - tag: scope
                  value: availability
        - uuid: 38a2dca1cca34a1988dd8713552c952b
          name: 'New Flow Count'
          type: DEPENDENT
          key: aws.elb.nlb.new_flow_count
          delay: '0'
          history: 7d
          description: 'The total number of new flows (or connections) established from clients to targets in the specified time period.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "NewFlowCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
        - uuid: a34d5ded1ec445b89a681a39b854b6cd
          name: 'New Flow Count TCP'
          type: DEPENDENT
          key: aws.elb.nlb.new_flow_count_tcp
          delay: '0'
          history: 7d
          description: 'The total number of new TCP flows (or connections) established from clients to targets in the specified time period.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "NewFlowCount_TCP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: tcp
        - uuid: 25ec5461aa3f477c8698d3b31ed3263c
          name: 'New Flow Count TLS'
          type: DEPENDENT
          key: aws.elb.nlb.new_flow_count_tls
          delay: '0'
          history: 7d
          description: 'The total number of new TLS flows (or connections) established from clients to targets in the specified time period.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "NewFlowCount_TLS")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: tls
        - uuid: 3f8fb9c0de524d0b9f157a9291fd7f27
          name: 'New Flow Count UDP'
          type: DEPENDENT
          key: aws.elb.nlb.new_flow_count_udp
          delay: '0'
          history: 7d
          description: 'The total number of new UDP flows (or connections) established from clients to targets in the specified time period.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "NewFlowCount_UDP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: udp
        - uuid: ffda7926a52c438c8195f70d772a4f7e
          name: 'Peak Packets per second'
          type: DEPENDENT
          key: aws.elb.nlb.peak_packets.rate
          delay: '0'
          history: 7d
          description: |
            Highest average packet rate (packets processed per second), calculated every 10 seconds during the sampling window.
            This metric includes health check traffic.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "PeakPacketsPerSecond")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
            - tag: component
              value: traffic
        - uuid: e83d4c875f414628987989a8e5e27c9e
          name: 'Port Allocation Error Count'
          type: DEPENDENT
          key: aws.elb.nlb.port_allocation_error_count
          delay: '0'
          history: 7d
          description: |
            The total number of ephemeral port allocation errors during a client IP translation operation. A non-zero value indicates dropped client connections.
            Note: Network Load Balancers support 55,000 simultaneous connections or about 55,000 connections per minute to each unique target (IP address and port) when performing client address translation.
            To fix port allocation errors, add more targets to the target group.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "PortAllocationErrorCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: health
        - uuid: 38cca57bd12048558d8569e6a9d18492
          name: 'Processed Bytes'
          type: DEPENDENT
          key: aws.elb.nlb.processed_bytes
          delay: '0'
          history: 7d
          units: B
          description: 'The total number of bytes processed by the load balancer, including TCP/IP headers. This count includes traffic to and from targets, minus health check traffic.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ProcessedBytes")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: traffic
        - uuid: a6b272d40c3d4b72adcced4aadaa607c
          name: 'Processed Bytes TCP'
          type: DEPENDENT
          key: aws.elb.nlb.processed_bytes_tcp
          delay: '0'
          history: 7d
          units: B
          description: 'The total number of bytes processed by TCP listeners.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ProcessedBytes_TCP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: tcp
            - tag: component
              value: traffic
        - uuid: c1e6456cd23446808299396f6368d6a9
          name: 'Processed Bytes TLS'
          type: DEPENDENT
          key: aws.elb.nlb.processed_bytes_tls
          delay: '0'
          history: 7d
          units: B
          description: 'The total number of bytes processed by TLS listeners.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ProcessedBytes_TLS")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: tls
            - tag: component
              value: traffic
        - uuid: 5c5e1be4725d4908adc0c506c98a6cab
          name: 'Processed Bytes UDP'
          type: DEPENDENT
          key: aws.elb.nlb.processed_bytes_udp
          delay: '0'
          history: 7d
          units: B
          description: 'The total number of bytes processed by UDP listeners.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ProcessedBytes_UDP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: traffic
            - tag: component
              value: udp
        - uuid: c41394db6dba4693b4c19aebdc2e8f69
          name: 'Processed Packets'
          type: DEPENDENT
          key: aws.elb.nlb.processed_packets
          delay: '0'
          history: 7d
          description: 'The total number of packets processed by the load balancer. This count includes traffic to and from targets, including health check traffic.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ProcessedPackets")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: traffic
        - uuid: 28bb42c1af9d4ee782a4ac1e75194293
          name: 'Security Group Blocked Flow Count Inbound ICMP'
          type: DEPENDENT
          key: aws.elb.nlb.sg_blocked_inbound_icmp
          delay: '0'
          history: 7d
          description: 'The number of new ICMP messages rejected by the inbound rules of the load balancer security groups.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "SecurityGroupBlockedFlowCount_Inbound_ICMP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: icmp
            - tag: component
              value: security-group
        - uuid: 95db8688978d4fc0b3a54c01c34cd0c7
          name: 'Security Group Blocked Flow Count Inbound TCP'
          type: DEPENDENT
          key: aws.elb.nlb.sg_blocked_inbound_tcp
          delay: '0'
          history: 7d
          description: 'The number of new TCP flows rejected by the inbound rules of the load balancer security groups.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "SecurityGroupBlockedFlowCount_Inbound_TCP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: security-group
            - tag: component
              value: tcp
        - uuid: 287e26627214470bba9589af506ca832
          name: 'Security Group Blocked Flow Count Inbound UDP'
          type: DEPENDENT
          key: aws.elb.nlb.sg_blocked_inbound_udp
          delay: '0'
          history: 7d
          description: 'The number of new UDP flows rejected by the inbound rules of the load balancer security groups.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "SecurityGroupBlockedFlowCount_Inbound_UDP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: security-group
            - tag: component
              value: udp
        - uuid: 65a6fb4771114377bcdf93dc09665b2b
          name: 'Security Group Blocked Flow Count Outbound ICMP'
          type: DEPENDENT
          key: aws.elb.nlb.sg_blocked_outbound_icmp
          delay: '0'
          history: 7d
          description: 'The number of new ICMP messages rejected by the outbound rules of the load balancer security groups.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "SecurityGroupBlockedFlowCount_Outbound_ICMP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: icmp
            - tag: component
              value: security-group
        - uuid: 343b254cfc1a48cc8e401cd3514c76b3
          name: 'Security Group Blocked Flow Count Outbound TCP'
          type: DEPENDENT
          key: aws.elb.nlb.sg_blocked_outbound_tcp
          delay: '0'
          history: 7d
          description: 'The number of new TCP flows rejected by the outbound rules of the load balancer security groups.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "SecurityGroupBlockedFlowCount_Outbound_TCP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: security-group
            - tag: component
              value: tcp
        - uuid: 5a9126687a964f969270bc1855081a7a
          name: 'Security Group Blocked Flow Count Outbound UDP'
          type: DEPENDENT
          key: aws.elb.nlb.sg_blocked_outbound_udp
          delay: '0'
          history: 7d
          description: 'The number of new UDP flows rejected by the outbound rules of the load balancer security groups.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "SecurityGroupBlockedFlowCount_Outbound_UDP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: security-group
            - tag: component
              value: udp
        - uuid: 583872d175174881a8cdcede4fe641e7
          name: 'Target TLS Negotiation Error Count'
          type: DEPENDENT
          key: aws.elb.nlb.target_tls_negotiation_error_count
          delay: '0'
          history: 7d
          description: 'The total number of TLS handshakes that failed during negotiation between a TLS listener and a target.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TargetTLSNegotiationErrorCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
            - tag: component
              value: tls
        - uuid: 035021358b9f4ae2b0478d5168fc1501
          name: 'TCP Client Reset Count'
          type: DEPENDENT
          key: aws.elb.nlb.tcp_client_reset_count
          delay: '0'
          history: 7d
          description: |
            The total number of reset (RST) packets sent from a client to a target.
            These resets are generated by the client and forwarded by the load balancer.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TCP_Client_Reset_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
            - tag: component
              value: tcp
        - uuid: 84f23b89fb414731979941a9a4701025
          name: 'TCP ELB Reset Count'
          type: DEPENDENT
          key: aws.elb.nlb.tcp_elb_reset_count
          delay: '0'
          history: 7d
          description: |
            The total number of reset (RST) packets generated by the load balancer.
            For more information, see: https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-troubleshooting.html#elb-reset-count-metric
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TCP_ELB_Reset_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
            - tag: component
              value: tcp
        - uuid: 3318c330736e406c9eec5f581f3fc59b
          name: 'TCP Target Reset Count'
          type: DEPENDENT
          key: aws.elb.nlb.tcp_target_reset_count
          delay: '0'
          history: 7d
          description: |
            The total number of reset (RST) packets sent from a target to a client.
            These resets are generated by the target and forwarded by the load balancer.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TCP_Target_Reset_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
            - tag: component
              value: tcp
        - uuid: 706019d7a11e48a9aaa1b5484c93fd8e
          name: 'Unhealthy Routing Flow Count'
          type: DEPENDENT
          key: aws.elb.nlb.unhealthy_routing_flow_count
          delay: '0'
          history: 7d
          description: 'The number of flows (or connections) that are routed using the routing failover action (fail open).'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "UnhealthyRoutingFlowCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
      discovery_rules:
        - uuid: 92bef05094464c16b03b37f1f797d436
          name: 'Load Balancer alarm discovery'
          type: DEPENDENT
          key: aws.elb.nlb.alarms.discovery
          delay: '0'
          filter:
            evaltype: AND
            conditions:
              - macro: '{#ALARM_NAME}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.MATCHES}'
                formulaid: A
              - macro: '{#ALARM_NAME}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#ALARM_SERVICE_NAMESPACE}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.MATCHES}'
                formulaid: C
              - macro: '{#ALARM_SERVICE_NAMESPACE}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Used for the discovery of alarm balancers.'
          item_prototypes:
            - uuid: c9f5791fe83743739ab74289126c7843
              name: '[{#ALARM_NAME}]: Get metrics'
              type: DEPENDENT
              key: 'aws.elb.nlb.alarm.get_metrics["{#ALARM_NAME}"]'
              delay: '0'
              history: '0'
              trends: '0'
              value_type: TEXT
              description: 'Get metrics about the alarm state and its reason.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.AlarmName == "{#ALARM_NAME}")].first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: aws.elb.nlb.get_alarms
              tags:
                - tag: component
                  value: raw
            - uuid: 3e039e2d86654095b0c9fa93f7273cab
              name: '[{#ALARM_NAME}]: State'
              type: DEPENDENT
              key: 'aws.elb.nlb.alarm.state["{#ALARM_NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The value of the alarm state. Possible values:
                0 - OK;
                1 - INSUFFICIENT_DATA;
                2 - ALARM.
                Alarm description:
                `{#ALARM_DESCRIPTION}`
              valuemap:
                name: 'Alarm state'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.StateValue
                  error_handler: CUSTOM_VALUE
                  error_handler_params: '3'
                - type: JAVASCRIPT
                  parameters:
                    - |
                      var state = ['OK', 'INSUFFICIENT_DATA', 'ALARM'];
                      
                      return state.indexOf(value.trim()) === -1 ? 255 : state.indexOf(value.trim());
              master_item:
                key: 'aws.elb.nlb.alarm.get_metrics["{#ALARM_NAME}"]'
              tags:
                - tag: component
                  value: alarms
              trigger_prototypes:
                - uuid: 0df06bb3cad742368204984c83f3c161
                  expression: 'last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.alarm.state["{#ALARM_NAME}"])=1'
                  name: '[{#ALARM_NAME}] has ''Insufficient data'' state'
                  event_name: '[{#ALARM_NAME}] has ''Insufficient data'' state'
                  opdata: 'Current value: {ITEM.LASTVALUE1}'
                  priority: INFO
                  description: 'Either the alarm has just started, the metric is not available, or not enough data is available for the metric to determine the alarm state.'
                  tags:
                    - tag: scope
                      value: notice
            - uuid: 8be7e86d50be4324ac6b7b8f20350eb0
              name: '[{#ALARM_NAME}]: State reason'
              type: DEPENDENT
              key: 'aws.elb.nlb.alarm.state_reason["{#ALARM_NAME}"]'
              delay: '0'
              history: 7d
              trends: '0'
              value_type: TEXT
              description: |
                An explanation for the alarm state reason in text format.
                Alarm description:
                `{#ALARM_DESCRIPTION}`
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.StateReason
                  error_handler: DISCARD_VALUE
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'aws.elb.nlb.alarm.get_metrics["{#ALARM_NAME}"]'
              tags:
                - tag: component
                  value: alarms
          trigger_prototypes:
            - uuid: a4558b07342b4e758cde7866e9027acf
              expression: 'last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.alarm.state["{#ALARM_NAME}"])=2 and length(last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.alarm.state_reason["{#ALARM_NAME}"]))>0'
              name: '[{#ALARM_NAME}] has ''Alarm'' state'
              event_name: '[{#ALARM_NAME}] has ''Alarm'' state (reason: {ITEM.LASTVALUE2})'
              opdata: 'Reason: {ITEM.LASTVALUE2}'
              priority: AVERAGE
              description: |
                The alarm `{#ALARM_NAME}` is in the ALARM state.
                Reason: `{ITEM.LASTVALUE2}`
              tags:
                - tag: scope
                  value: availability
          master_item:
            key: aws.elb.nlb.get_alarms
          preprocessing:
            - type: JAVASCRIPT
              parameters:
                - |
                  var result = [];
                  var alarms = JSON.parse(value);
                  
                  alarms.forEach(function(alarm) {
                  
                   result.push({
                  '{#ALARM_DESCRIPTION}': alarm.AlarmDescription !== null ? alarm.AlarmDescription : 'None' ,
                  '{#ALARM_NAME}': alarm.AlarmName,
                  '{#ALARM_PERIOD}': alarm.Period,
                  '{#METRIC_NAME}': alarm.MetricName,
                  '{#ALARM_SERVICE_NAMESPACE}': alarm.Namespace !== null ? alarm.Namespace : 'None'
                    });
                  });
                  
                  return JSON.stringify(result);
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: bc0fa68299464e2ebb031b005bd7041a
          name: 'Target groups discovery'
          type: DEPENDENT
          key: aws.elb.nlb.target_groups.discovery
          delay: '0'
          filter:
            evaltype: AND
            conditions:
              - macro: '{#AWS.ELB.TARGET.GROUP.NAME}'
                value: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.MATCHES}'
                formulaid: A
              - macro: '{#AWS.ELB.TARGET.GROUP.NAME}'
                value: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
          description: 'Used for the discovery of `{$AWS.ELB.TARGET.GROUP.NAME}` target groups.'
          item_prototypes:
            - uuid: 9438a03b48bd4617a2363f83f758f107
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Get metrics'
              type: SCRIPT
              key: 'aws.elb.nlb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: 0s;m/5
              history: '0'
              trends: '0'
              value_type: TEXT
              params: |
                var AWS = {
                	params: {},
                	metadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',
                	request_period: 60,
                
                	getField: function (data, path) {
                		var steps = path.split('.');
                		for (var i = 0; i < steps.length; i++) {
                			var step = steps[i];
                			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
                				throw 'Required field was not found: ' + path;
                			}
                
                			data = data[step];
                		}
                
                		return data;
                	},
                
                	setParams: function (params) {
                		AWS.params['proxy'] = params.proxy;
                		switch (AWS.getField(params, 'auth_type')) {
                			case 'role_base':
                				AWS.params['auth_type'] = 'role_base';
                				var request = new HttpRequest();
                				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                					request.setProxy(AWS.params.proxy);
                				}
                				var IamRoleName = request.get(AWS.metadata);
                
                				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
                					throw 'Error getting security credentials from instance metadata. Role not found.';
                				}
                
                				credentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));
                
                				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
                					throw 'Error getting security credentials from instance metadata.';
                				}
                
                				try {
                					credentials = JSON.parse(credentials);
                				}
                				catch (error) {
                					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
                				}
                
                				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
                					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
                						throw 'Required credentials are not set: "' + field + '".';
                					};
                					AWS.params[field] = credentials[field];
                				});
                				break;
                			case 'access_key':
                			default:
                				AWS.params['auth_type'] = 'access_key';
                				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
                					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                						throw 'Required param is not set: "' + field + '".';
                					}
                					AWS.params[field] = params[field];
                				});
                		}
                		['region', 'arn', 'target_arn'].forEach(function (field) {
                			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                				throw 'Required param is not set: "' + field + '".';
                			}
                			AWS.params[field] = params[field];
                		});
                	},
                
                	sign: function (key, message) {
                		var hex = hmac('sha256', key, message);
                
                		if ((hex.length % 2) === 1) {
                			throw 'Invalid length of a hex string!';
                		}
                
                		var result = new Int8Array(hex.length / 2);
                		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
                			result[b] = parseInt(hex.substring(i, i + 2), 16);
                		}
                
                		return result;
                	},
                
                	renderMetricQuery: function (period, arn, target_arn) {
                		var metrics_list = [
                			'HealthyHostCount:Minimum',
                			'UnHealthyHostCount:Maximum'
                		],
                			regex = /loadbalancer\/(.+)$/;
                
                		var metric_payload = [];
                		metrics_list.forEach(function (metric, index) {
                			var parts = metric.split(':', 2);
                			metric_payload.push({
                				'Id': 'm' + index,
                				'MetricStat': {
                					'Metric': {
                						'MetricName': parts[0],
                						'Namespace': 'AWS/NetworkELB',
                						'Dimensions': [
                							{
                								'Name': 'LoadBalancer',
                								'Value': arn.match(regex)[1],
                							},
                							{
                								'Name': 'TargetGroup',
                								'Value': target_arn
                							}
                						]
                					},
                					'Period': period,
                					'Stat': parts[1],
                				}
                			});
                		});
                
                		return metric_payload;
                	},
                
                	request: function (method, region, service, data) {
                		if (typeof data === 'undefined' || data === null) {
                			data = JSON.stringify([]);
                		}
                		else {
                			data = JSON.stringify(data)
                		}
                		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
                			date = amzdate.replace(/T\d+Z/, ''),
                			canonical_uri = '/',
                			host = service + '.' + region + '.amazonaws.com';
                
                		if (AWS.params.auth_type === 'role_base') {
                			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n' + 'x-amz-security-token:' + AWS.params.Token + '\n',
                				signed_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';
                		} else {
                			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
                				signed_headers = 'content-encoding;host;x-amz-date';
                		}
                
                		canonical_request = method + '\n' + canonical_uri + '\n' + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data);
                		url = 'https://' + host + canonical_uri;
                
                		var credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
                			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
                			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
                
                		key = AWS.sign(key, region);
                		key = AWS.sign(key, service);
                		key = AWS.sign(key, 'aws4_request');
                
                		var request = new HttpRequest();
                
                		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                			request.setProxy(AWS.params.proxy);
                		}
                		request.addHeader('x-amz-date: ' + amzdate);
                		request.addHeader('x-amz-content-sha256:' + sha256(data));
                		request.addHeader('X-Amz-Target: GraniteServiceVersion20100801.GetMetricData')
                		request.addHeader('Accept: application/json');
                		request.addHeader('Content-Type: application/json');
                		request.addHeader('Content-Encoding: amz-1.0');
                		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
                		if (AWS.params.auth_type === 'role_base')
                			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
                
                		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
                		response = request.post(url, data);
                		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
                		if (request.getStatus() !== 200) {
                			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
                		}
                
                		return JSON.parse(response);
                	},
                
                	getMetricsData: function () {
                		var end_time = Math.floor((new Date().getTime()) / 1000),
                			start_time = end_time - AWS.request_period * 60;
                		payload = {
                			'StartTime': start_time,
                			'EndTime': end_time,
                			'ScanBy': 'TimestampDescending',
                			'MetricDataQueries': AWS.renderMetricQuery(AWS.request_period, AWS.params.arn, AWS.params.target_arn)
                		};
                
                		return AWS.getField(AWS.request('POST', AWS.params.region, 'monitoring', payload), 'MetricDataResults');
                	}
                };
                
                try {
                	AWS.setParams(JSON.parse(value));
                	return JSON.stringify(AWS.getMetricsData());
                }
                catch (error) {
                	error += (String(error).endsWith('.')) ? '' : '.';
                	Zabbix.log(3, '[ AWS ELB Get targets group metrics] ERROR: ' + error);
                
                	return JSON.stringify({ 'error': error });
                }
              description: |
                Get the metrics of the ELB target group `{#AWS.ELB.TARGET.GROUP.NAME}`.
                Full list of metrics related to AWS ELB here: https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-cloudwatch-metrics.html#user-authentication-metric-table
              preprocessing:
                - type: CHECK_NOT_SUPPORTED
                  parameters:
                    - '-1'
              timeout: '{$AWS.DATA.TIMEOUT}'
              parameters:
                - name: AccessKeyId
                  value: '{$AWS.ACCESS.KEY.ID}'
                - name: arn
                  value: '{$AWS.ELB.ARN}'
                - name: auth_type
                  value: '{$AWS.AUTH_TYPE}'
                - name: proxy
                  value: '{$AWS.PROXY}'
                - name: region
                  value: '{$AWS.REGION}'
                - name: SecretAccessKey
                  value: '{$AWS.SECRET.ACCESS.KEY}'
                - name: target_arn
                  value: '{#AWS.ELB.TARGET.GROUP.ARN}'
              tags:
                - tag: component
                  value: raw
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 8a42548bf31843acb0b021dfa0cf7f38
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy Host Count'
              type: DEPENDENT
              key: 'aws.elb.nlb.target_groups.healthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of targets that are considered healthy.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HealthyHostCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.nlb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
              trigger_prototypes:
                - uuid: dd527fbba0a84a1b8abe77dc34f7474c
                  expression: 'last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.target_groups.healthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]) = 0'
                  name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Target have become unhealthy'
                  event_name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy Host Count = 0'
                  opdata: 'Current value: {ITEM.LASTVALUE1}'
                  priority: AVERAGE
                  description: 'This trigger helps in identifying when your targets have become unhealthy.'
                  tags:
                    - tag: scope
                      value: availability
            - uuid: b5e01700b1a14cd1bcfb676c69490f86
              name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy Host Count'
              type: DEPENDENT
              key: 'aws.elb.nlb.target_groups.unhealthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of targets that are considered unhealthy.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "UnHealthyHostCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.nlb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
              trigger_prototypes:
                - uuid: 8de0720e39eb4759bec17431a596c3d4
                  expression: 'last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.target_groups.unhealthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]) > {$AWS.ELB.UNHEALTHY.HOST.MAX}'
                  name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Target have unhealthy host'
                  event_name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy Host Count > {$AWS.ELB.UNHEALTHY.HOST.MAX}'
                  opdata: 'Current value: {ITEM.LASTVALUE1}'
                  priority: WARNING
                  description: 'This trigger allows you to become aware when there are no more registered targets.'
                  dependencies:
                    - name: '[{#AWS.ELB.TARGET.GROUP.NAME}]: Target have become unhealthy'
                      expression: 'last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.target_groups.healthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]) = 0'
                  tags:
                    - tag: scope
                      value: availability
          graph_prototypes:
            - uuid: c83f16408b0e42b1b985fa02e00d49da
              name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy Host'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: 199C0D
                  item:
                    host: 'AWS ELB Network Load Balancer by HTTP'
                    key: 'aws.elb.nlb.target_groups.healthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: 2ddcf506cb344d58a8b2b555c0b90952
              name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy Host'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: FF0000
                  item:
                    host: 'AWS ELB Network Load Balancer by HTTP'
                    key: 'aws.elb.nlb.target_groups.unhealthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
          master_item:
            key: aws.elb.nlb.get_target_groups
          lld_macro_paths:
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.ARN}'
              path: $.target_arn
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.NAME}'
              path: $.target_name
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
              path: $.protocol
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.TYPE}'
              path: $.type
          preprocessing:
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
      tags:
        - tag: class
          value: software
        - tag: target
          value: aws
        - tag: target
          value: elb
        - tag: target
          value: nlb
      macros:
        - macro: '{$AWS.ACCESS.KEY.ID}'
          description: 'Access key ID.'
        - macro: '{$AWS.AUTH_TYPE}'
          value: access_key
          description: 'Authorization method. Possible values: `role_base`, `access_key`.'
        - macro: '{$AWS.DATA.TIMEOUT}'
          value: 60s
          description: 'API response timeout.'
        - macro: '{$AWS.ELB.ARN}'
          description: 'Amazon Resource Names (ARN) of the load balancer.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable alarms by name.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered alarms by name.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable alarms by namespace.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered alarms by namespace.'
        - macro: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable target groups by name.'
        - macro: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered target groups by name.'
        - macro: '{$AWS.ELB.UNHEALTHY.HOST.MAX}'
          value: '0'
          description: 'Maximum number of unhealthy hosts for a trigger expression.'
        - macro: '{$AWS.PROXY}'
          description: 'Sets the HTTP proxy value. If this macro is empty, no proxy is used.'
        - macro: '{$AWS.REGION}'
          value: us-west-1
          description: 'AWS Network Load Balancer region code.'
        - macro: '{$AWS.SECRET.ACCESS.KEY}'
          description: 'Secret access key.'
      dashboards:
        - uuid: 3b69323b2b8940b0a1fd0ae2ae2dc156
          name: 'Overview AWS ELB Network Load Balancer'
          pages:
            - name: 'AWS ELB NLB: Main'
              widgets:
                - type: item
                  name: 'Port Allocation Error Count'
                  width: '6'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: decimal_places
                      value: '0'
                    - type: ITEM
                      name: itemid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        key: aws.elb.nlb.port_allocation_error_count
                    - type: INTEGER
                      name: show.0
                      value: '2'
                - type: graph
                  'y': '5'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Peak Packets per second'
                    - type: STRING
                      name: reference
                      value: BDBEE
                - type: graph
                  'y': '10'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Concurrent Flows Count'
                    - type: STRING
                      name: reference
                      value: CFDBA
                - type: graph
                  'y': '15'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Consumed LCUs and Processed Bytes'
                    - type: STRING
                      name: reference
                      value: DECEC
                - type: graph
                  'y': '20'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Security Group Blocked Flow Count ICMP'
                    - type: STRING
                      name: reference
                      value: ADEED
                - type: graphprototype
                  x: '6'
                  width: '6'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy Host'
                    - type: STRING
                      name: reference
                      value: FDEFC
                - type: graphprototype
                  x: '12'
                  width: '6'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy Host'
                    - type: STRING
                      name: reference
                      value: EAAFA
                - type: item
                  name: 'Unhealthy Routing Flow Count'
                  x: '18'
                  width: '6'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: decimal_places
                      value: '0'
                    - type: ITEM
                      name: itemid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        key: aws.elb.nlb.unhealthy_routing_flow_count
                    - type: INTEGER
                      name: show.0
                      value: '2'
            - name: 'AWS ELB NLB: TCP'
              widgets:
                - type: graph
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: TCP Reset Count'
                    - type: STRING
                      name: reference
                      value: CCAAA
                - type: graph
                  'y': '5'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Consumed LCUs TCP and Processed Bytes TCP'
                    - type: STRING
                      name: reference
                      value: BEEDA
                - type: graph
                  'y': '10'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Concurrent Flows Count TCP'
                    - type: STRING
                      name: reference
                      value: FEBCF
                - type: graph
                  'y': '15'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Security Group Blocked Flow Count TCP'
                    - type: STRING
                      name: reference
                      value: ECBEF
            - name: 'AWS ELB NLB: TLS'
              widgets:
                - type: graph
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: TLS Negotiation Error Count'
                    - type: STRING
                      name: reference
                      value: CEAFF
                - type: graph
                  'y': '5'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Consumed LCUs TLS and Processed Bytes TLS'
                    - type: STRING
                      name: reference
                      value: DDCEF
                - type: graph
                  'y': '10'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Concurrent Flows Count TLS'
                    - type: STRING
                      name: reference
                      value: FABDD
            - name: 'AWS ELB NLB: UDP'
              widgets:
                - type: graph
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Consumed LCUs UDP and Processed Bytes UDP'
                    - type: STRING
                      name: reference
                      value: AEAEF
                - type: graph
                  'y': '5'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Concurrent Flows Count UDP'
                    - type: STRING
                      name: reference
                      value: EBDBF
                - type: graph
                  'y': '10'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Security Group Blocked Flow Count UDP'
                    - type: STRING
                      name: reference
                      value: CFFDB
      valuemaps:
        - uuid: e0e5308401bd4abfa79ba604c0481d2a
          name: 'Alarm state'
          mappings:
            - value: '0'
              newvalue: OK
            - value: '1'
              newvalue: 'Insufficient data'
            - value: '2'
              newvalue: Alarm
            - value: '255'
              newvalue: Unknown
  graphs:
    - uuid: b19f7d65ad1d469d8396b03111d38e52
      name: 'AWS ELB ALB: Connection Count'
      graph_items:
        - drawtype: BOLD_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.alb.active_connection_count
        - sortorder: '1'
          drawtype: BOLD_LINE
          color: F63100
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.alb.new_connection_count
        - sortorder: '2'
          drawtype: BOLD_LINE
          color: 00611C
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.alb.rejected_connection_count
        - sortorder: '3'
          drawtype: BOLD_LINE
          color: F7941D
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.alb.target_connection_error_count
    - uuid: fb034590cbc34b0aa297b77c1f320684
      name: 'AWS ELB ALB: Consumed LCUs and Processed Bytes'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.alb.capacity_units
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          yaxisside: RIGHT
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.alb.processed_bytes
    - uuid: a711d08edbd04abe890ab2b8cdf6d41b
      name: 'AWS ELB ALB: HTTP Code'
      graph_items:
        - drawtype: BOLD_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.alb.http_3xx_count
        - sortorder: '1'
          drawtype: BOLD_LINE
          color: F63100
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.alb.http_4xx_count
        - sortorder: '2'
          drawtype: BOLD_LINE
          color: 00611C
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.alb.http_5xx_count
    - uuid: 4ee7ac4174b74f869e04dab5d76219ab
      name: 'AWS ELB ALB: Requests Count and Response Time'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.alb.requests_count
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          yaxisside: RIGHT
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.alb.target_response_time
    - uuid: 07118e148b0744ec98750733d1b5284c
      name: 'AWS ELB NLB: Concurrent Flows Count'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.active_flow_count
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count
    - uuid: a13750d46d834d65a881396ecedaa813
      name: 'AWS ELB NLB: Concurrent Flows Count TCP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.active_flow_count_tcp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count_tcp
    - uuid: 3b4ccb4dc50b4bf49ef45b517a65e6e8
      name: 'AWS ELB NLB: Concurrent Flows Count TLS'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.active_flow_count_tls
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count_tls
    - uuid: 670bad5c2264431cb60b3a0b9c5cf111
      name: 'AWS ELB NLB: Concurrent Flows Count UDP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.active_flow_count_udp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count_udp
    - uuid: c16c89c1a5da4aafbd8151f982cade2d
      name: 'AWS ELB NLB: Consumed LCUs and Processed Bytes'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.capacity_units
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          yaxisside: RIGHT
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.processed_bytes
    - uuid: c5718fb3ddfd4642ba2dbd914a1fe6ac
      name: 'AWS ELB NLB: Consumed LCUs TCP and Processed Bytes TCP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.capacity_units_tcp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          yaxisside: RIGHT
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.processed_bytes_tcp
    - uuid: 7b5d11acc0dc4d19b4d0a797570400e7
      name: 'AWS ELB NLB: Consumed LCUs TLS and Processed Bytes TLS'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.capacity_units_tls
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          yaxisside: RIGHT
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.processed_bytes_tls
    - uuid: 355fb45cbaef4dfb9050ca84fbfba83b
      name: 'AWS ELB NLB: Consumed LCUs UDP and Processed Bytes UDP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.capacity_units_udp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          yaxisside: RIGHT
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.processed_bytes_udp
    - uuid: e2023c7d365b45629ccf61f853229bcb
      name: 'AWS ELB NLB: New Flow Count'
      graph_items:
        - drawtype: BOLD_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count
        - sortorder: '1'
          drawtype: BOLD_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count_tcp
        - sortorder: '2'
          drawtype: BOLD_LINE
          color: 00611C
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count_tls
        - sortorder: '3'
          drawtype: BOLD_LINE
          color: F7941D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count_udp
    - uuid: 457264f4a11a4a4dbac3314875b04ac0
      name: 'AWS ELB NLB: Peak Packets per second'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.peak_packets.rate
    - uuid: 7db2aa4f6f454b06ba3c9e01259a1a24
      name: 'AWS ELB NLB: Security Group Blocked Flow Count ICMP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.sg_blocked_inbound_icmp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.sg_blocked_outbound_icmp
    - uuid: bf724b8819804cb385f6448f2f6133ac
      name: 'AWS ELB NLB: Security Group Blocked Flow Count TCP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.sg_blocked_inbound_tcp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.sg_blocked_outbound_tcp
    - uuid: 3162f3656a154c9280bda0539c6e102c
      name: 'AWS ELB NLB: Security Group Blocked Flow Count UDP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.sg_blocked_inbound_udp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.sg_blocked_outbound_udp
    - uuid: 561b3f02b2964c5d8dce2b2b6d2556d4
      name: 'AWS ELB NLB: TCP Reset Count'
      graph_items:
        - drawtype: BOLD_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.tcp_client_reset_count
        - sortorder: '1'
          drawtype: BOLD_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.tcp_elb_reset_count
        - sortorder: '2'
          drawtype: BOLD_LINE
          color: 00611C
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.tcp_target_reset_count
    - uuid: 87c58ec6a1ee4c9abde81e10af999d79
      name: 'AWS ELB NLB: TLS Negotiation Error Count'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.client_tls_negotiation_error_count
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.target_tls_negotiation_error_count
